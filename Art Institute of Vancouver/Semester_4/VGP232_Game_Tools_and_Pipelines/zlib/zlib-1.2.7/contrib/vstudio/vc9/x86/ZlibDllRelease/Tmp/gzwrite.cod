; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.21022.08 

	TITLE	f:\Semester 4\VGP232 Game Tools & Pipelines\zlib\zlib-1.2.7\gzwrite.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5c@ ; `string'
EXTRN	_vsnprintf:PROC
EXTRN	_write:PROC
;	COMDAT ??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5c@
CONST	SEGMENT
??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5c@ DB 'internal er'
	DB	'ror: deflate stream corrupt', 00H		; `string'
; Function compile flags: /Odtp
; File f:\semester 4\vgp232 game tools & pipelines\zlib\zlib-1.2.7\gzwrite.c
;	COMDAT _gz_init
_TEXT	SEGMENT
_ret$ = -8						; size = 4
_strm$ = -4						; size = 4
_state$ = 8						; size = 4
_gz_init PROC						; COMDAT

; 17   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 18   :     int ret;
; 19   :     z_streamp strm = &(state->strm);

  00006	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00009	83 c0 64	 add	 eax, 100		; 00000064H
  0000c	89 45 fc	 mov	 DWORD PTR _strm$[ebp], eax

; 20   : 
; 21   :     /* allocate input buffer */
; 22   :     state->in = malloc(state->want);

  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00012	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00015	52		 push	 edx
  00016	e8 00 00 00 00	 call	 _malloc
  0001b	83 c4 04	 add	 esp, 4
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00021	89 41 24	 mov	 DWORD PTR [ecx+36], eax

; 23   :     if (state->in == NULL) {

  00024	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00027	83 7a 24 00	 cmp	 DWORD PTR [edx+36], 0
  0002b	75 1b		 jne	 SHORT $LN5@gz_init

; 24   :         gz_error(state, Z_MEM_ERROR, "out of memory");

  0002d	68 00 00 00 00	 push	 OFFSET ??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  00032	6a fc		 push	 -4			; fffffffcH
  00034	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 _gz_error
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 25   :         return -1;

  00040	83 c8 ff	 or	 eax, -1
  00043	e9 11 01 00 00	 jmp	 $LN6@gz_init
$LN5@gz_init:

; 26   :     }
; 27   : 
; 28   :     /* only need output buffer and deflate state if compressing */
; 29   :     if (!state->direct) {

  00048	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0004b	83 79 2c 00	 cmp	 DWORD PTR [ecx+44], 0
  0004f	0f 85 c9 00 00
	00		 jne	 $LN4@gz_init

; 30   :         /* allocate output buffer */
; 31   :         state->out = malloc(state->want);

  00055	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00058	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 _malloc
  00061	83 c4 04	 add	 esp, 4
  00064	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00067	89 41 28	 mov	 DWORD PTR [ecx+40], eax

; 32   :         if (state->out == NULL) {

  0006a	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0006d	83 7a 28 00	 cmp	 DWORD PTR [edx+40], 0
  00071	75 2a		 jne	 SHORT $LN3@gz_init

; 33   :             free(state->in);

  00073	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00076	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00079	51		 push	 ecx
  0007a	e8 00 00 00 00	 call	 _free
  0007f	83 c4 04	 add	 esp, 4

; 34   :             gz_error(state, Z_MEM_ERROR, "out of memory");

  00082	68 00 00 00 00	 push	 OFFSET ??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  00087	6a fc		 push	 -4			; fffffffcH
  00089	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0008c	52		 push	 edx
  0008d	e8 00 00 00 00	 call	 _gz_error
  00092	83 c4 0c	 add	 esp, 12			; 0000000cH

; 35   :             return -1;

  00095	83 c8 ff	 or	 eax, -1
  00098	e9 bc 00 00 00	 jmp	 $LN6@gz_init
$LN3@gz_init:

; 36   :         }
; 37   : 
; 38   :         /* allocate deflate memory, set up for gzip compression */
; 39   :         strm->zalloc = Z_NULL;

  0009d	8b 45 fc	 mov	 eax, DWORD PTR _strm$[ebp]
  000a0	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0

; 40   :         strm->zfree = Z_NULL;

  000a7	8b 4d fc	 mov	 ecx, DWORD PTR _strm$[ebp]
  000aa	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], 0

; 41   :         strm->opaque = Z_NULL;

  000b1	8b 55 fc	 mov	 edx, DWORD PTR _strm$[ebp]
  000b4	c7 42 28 00 00
	00 00		 mov	 DWORD PTR [edx+40], 0

; 42   :         ret = deflateInit2(strm, state->level, Z_DEFLATED,
; 43   :                            MAX_WBITS + 16, DEF_MEM_LEVEL, state->strategy);

  000bb	6a 38		 push	 56			; 00000038H
  000bd	68 00 00 00 00	 push	 OFFSET ??_C@_05HBMOAMF@1?42?47?$AA@
  000c2	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000c5	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  000c8	51		 push	 ecx
  000c9	6a 08		 push	 8
  000cb	6a 1f		 push	 31			; 0000001fH
  000cd	6a 08		 push	 8
  000cf	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000d2	8b 42 48	 mov	 eax, DWORD PTR [edx+72]
  000d5	50		 push	 eax
  000d6	8b 4d fc	 mov	 ecx, DWORD PTR _strm$[ebp]
  000d9	51		 push	 ecx
  000da	e8 00 00 00 00	 call	 _deflateInit2_@32
  000df	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax

; 44   :         if (ret != Z_OK) {

  000e2	83 7d f8 00	 cmp	 DWORD PTR _ret$[ebp], 0
  000e6	74 36		 je	 SHORT $LN4@gz_init

; 45   :             free(state->out);

  000e8	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000eb	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  000ee	50		 push	 eax
  000ef	e8 00 00 00 00	 call	 _free
  000f4	83 c4 04	 add	 esp, 4

; 46   :             free(state->in);

  000f7	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  000fa	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  000fd	52		 push	 edx
  000fe	e8 00 00 00 00	 call	 _free
  00103	83 c4 04	 add	 esp, 4

; 47   :             gz_error(state, Z_MEM_ERROR, "out of memory");

  00106	68 00 00 00 00	 push	 OFFSET ??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  0010b	6a fc		 push	 -4			; fffffffcH
  0010d	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00110	50		 push	 eax
  00111	e8 00 00 00 00	 call	 _gz_error
  00116	83 c4 0c	 add	 esp, 12			; 0000000cH

; 48   :             return -1;

  00119	83 c8 ff	 or	 eax, -1
  0011c	eb 3b		 jmp	 SHORT $LN6@gz_init
$LN4@gz_init:

; 49   :         }
; 50   :     }
; 51   : 
; 52   :     /* mark state as initialized */
; 53   :     state->size = state->want;

  0011e	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00121	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00124	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00127	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 54   : 
; 55   :     /* initialize write buffer if compressing */
; 56   :     if (!state->direct) {

  0012a	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0012d	83 79 2c 00	 cmp	 DWORD PTR [ecx+44], 0
  00131	75 24		 jne	 SHORT $LN1@gz_init

; 57   :         strm->avail_out = state->size;

  00133	8b 55 fc	 mov	 edx, DWORD PTR _strm$[ebp]
  00136	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00139	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0013c	89 4a 10	 mov	 DWORD PTR [edx+16], ecx

; 58   :         strm->next_out = state->out;

  0013f	8b 55 fc	 mov	 edx, DWORD PTR _strm$[ebp]
  00142	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00145	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00148	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 59   :         state->x.next = strm->next_out;

  0014b	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0014e	8b 45 fc	 mov	 eax, DWORD PTR _strm$[ebp]
  00151	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00154	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN1@gz_init:

; 60   :     }
; 61   :     return 0;

  00157	33 c0		 xor	 eax, eax
$LN6@gz_init:

; 62   : }

  00159	8b e5		 mov	 esp, ebp
  0015b	5d		 pop	 ebp
  0015c	c3		 ret	 0
_gz_init ENDP
; Function compile flags: /Odtp
;	COMDAT _gz_comp
_TEXT	SEGMENT
_got$ = -16						; size = 4
_ret$ = -12						; size = 4
_strm$ = -8						; size = 4
_have$ = -4						; size = 4
_state$ = 8						; size = 4
_flush$ = 12						; size = 4
_gz_comp PROC						; COMDAT

; 73   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 74   :     int ret, got;
; 75   :     unsigned have;
; 76   :     z_streamp strm = &(state->strm);

  00006	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00009	83 c0 64	 add	 eax, 100		; 00000064H
  0000c	89 45 f8	 mov	 DWORD PTR _strm$[ebp], eax

; 77   : 
; 78   :     /* allocate memory if this is the first time through */
; 79   :     if (state->size == 0 && gz_init(state) == -1)

  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00012	83 79 1c 00	 cmp	 DWORD PTR [ecx+28], 0
  00016	75 19		 jne	 SHORT $LN15@gz_comp
  00018	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0001b	52		 push	 edx
  0001c	e8 00 00 00 00	 call	 _gz_init
  00021	83 c4 04	 add	 esp, 4
  00024	83 f8 ff	 cmp	 eax, -1
  00027	75 08		 jne	 SHORT $LN15@gz_comp

; 80   :         return -1;

  00029	83 c8 ff	 or	 eax, -1
  0002c	e9 85 01 00 00	 jmp	 $LN16@gz_comp
$LN15@gz_comp:

; 81   : 
; 82   :     /* write directly if requested */
; 83   :     if (state->direct) {

  00031	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00034	83 78 2c 00	 cmp	 DWORD PTR [eax+44], 0
  00038	74 68		 je	 SHORT $LN14@gz_comp

; 84   :         got = write(state->fd, strm->next_in, strm->avail_in);

  0003a	8b 4d f8	 mov	 ecx, DWORD PTR _strm$[ebp]
  0003d	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00040	52		 push	 edx
  00041	8b 45 f8	 mov	 eax, DWORD PTR _strm$[ebp]
  00044	8b 08		 mov	 ecx, DWORD PTR [eax]
  00046	51		 push	 ecx
  00047	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0004a	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 _write
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH
  00056	89 45 f0	 mov	 DWORD PTR _got$[ebp], eax

; 85   :         if (got < 0 || (unsigned)got != strm->avail_in) {

  00059	83 7d f0 00	 cmp	 DWORD PTR _got$[ebp], 0
  0005d	7c 0b		 jl	 SHORT $LN12@gz_comp
  0005f	8b 4d f8	 mov	 ecx, DWORD PTR _strm$[ebp]
  00062	8b 55 f0	 mov	 edx, DWORD PTR _got$[ebp]
  00065	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00068	74 27		 je	 SHORT $LN13@gz_comp
$LN12@gz_comp:

; 86   :             gz_error(state, Z_ERRNO, zstrerror());

  0006a	e8 00 00 00 00	 call	 __errno
  0006f	8b 00		 mov	 eax, DWORD PTR [eax]
  00071	50		 push	 eax
  00072	e8 00 00 00 00	 call	 _strerror
  00077	83 c4 04	 add	 esp, 4
  0007a	50		 push	 eax
  0007b	6a ff		 push	 -1
  0007d	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00080	51		 push	 ecx
  00081	e8 00 00 00 00	 call	 _gz_error
  00086	83 c4 0c	 add	 esp, 12			; 0000000cH

; 87   :             return -1;

  00089	83 c8 ff	 or	 eax, -1
  0008c	e9 25 01 00 00	 jmp	 $LN16@gz_comp
$LN13@gz_comp:

; 88   :         }
; 89   :         strm->avail_in = 0;

  00091	8b 55 f8	 mov	 edx, DWORD PTR _strm$[ebp]
  00094	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 90   :         return 0;

  0009b	33 c0		 xor	 eax, eax
  0009d	e9 14 01 00 00	 jmp	 $LN16@gz_comp
$LN14@gz_comp:

; 91   :     }
; 92   : 
; 93   :     /* run deflate() on provided input until it produces no more output */
; 94   :     ret = Z_OK;

  000a2	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 0
$LN11@gz_comp:

; 95   :     do {
; 96   :         /* write out current buffer contents if full, or if flushing, but if
; 97   :            doing Z_FINISH then don't write until we get to Z_STREAM_END */
; 98   :         if (strm->avail_out == 0 || (flush != Z_NO_FLUSH &&
; 99   :             (flush != Z_FINISH || ret == Z_STREAM_END))) {

  000a9	8b 45 f8	 mov	 eax, DWORD PTR _strm$[ebp]
  000ac	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  000b0	74 1a		 je	 SHORT $LN7@gz_comp
  000b2	83 7d 0c 00	 cmp	 DWORD PTR _flush$[ebp], 0
  000b6	0f 84 a0 00 00
	00		 je	 $LN8@gz_comp
  000bc	83 7d 0c 04	 cmp	 DWORD PTR _flush$[ebp], 4
  000c0	75 0a		 jne	 SHORT $LN7@gz_comp
  000c2	83 7d f4 01	 cmp	 DWORD PTR _ret$[ebp], 1
  000c6	0f 85 90 00 00
	00		 jne	 $LN8@gz_comp
$LN7@gz_comp:

; 100  :             have = (unsigned)(strm->next_out - state->x.next);

  000cc	8b 4d f8	 mov	 ecx, DWORD PTR _strm$[ebp]
  000cf	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000d2	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  000d5	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  000d8	89 45 fc	 mov	 DWORD PTR _have$[ebp], eax

; 101  :             if (have && ((got = write(state->fd, state->x.next, have)) < 0 ||
; 102  :                          (unsigned)got != have)) {

  000db	74 52		 je	 SHORT $LN5@gz_comp
  000dd	8b 4d fc	 mov	 ecx, DWORD PTR _have$[ebp]
  000e0	51		 push	 ecx
  000e1	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000e4	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000e7	50		 push	 eax
  000e8	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  000eb	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  000ee	52		 push	 edx
  000ef	e8 00 00 00 00	 call	 _write
  000f4	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f7	89 45 f0	 mov	 DWORD PTR _got$[ebp], eax
  000fa	83 7d f0 00	 cmp	 DWORD PTR _got$[ebp], 0
  000fe	7c 08		 jl	 SHORT $LN4@gz_comp
  00100	8b 45 f0	 mov	 eax, DWORD PTR _got$[ebp]
  00103	3b 45 fc	 cmp	 eax, DWORD PTR _have$[ebp]
  00106	74 27		 je	 SHORT $LN5@gz_comp
$LN4@gz_comp:

; 103  :                 gz_error(state, Z_ERRNO, zstrerror());

  00108	e8 00 00 00 00	 call	 __errno
  0010d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0010f	51		 push	 ecx
  00110	e8 00 00 00 00	 call	 _strerror
  00115	83 c4 04	 add	 esp, 4
  00118	50		 push	 eax
  00119	6a ff		 push	 -1
  0011b	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0011e	52		 push	 edx
  0011f	e8 00 00 00 00	 call	 _gz_error
  00124	83 c4 0c	 add	 esp, 12			; 0000000cH

; 104  :                 return -1;

  00127	83 c8 ff	 or	 eax, -1
  0012a	e9 87 00 00 00	 jmp	 $LN16@gz_comp
$LN5@gz_comp:

; 105  :             }
; 106  :             if (strm->avail_out == 0) {

  0012f	8b 45 f8	 mov	 eax, DWORD PTR _strm$[ebp]
  00132	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00136	75 18		 jne	 SHORT $LN3@gz_comp

; 107  :                 strm->avail_out = state->size;

  00138	8b 4d f8	 mov	 ecx, DWORD PTR _strm$[ebp]
  0013b	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0013e	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00141	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 108  :                 strm->next_out = state->out;

  00144	8b 4d f8	 mov	 ecx, DWORD PTR _strm$[ebp]
  00147	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0014a	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  0014d	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
$LN3@gz_comp:

; 109  :             }
; 110  :             state->x.next = strm->next_out;

  00150	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00153	8b 55 f8	 mov	 edx, DWORD PTR _strm$[ebp]
  00156	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00159	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN8@gz_comp:

; 111  :         }
; 112  : 
; 113  :         /* compress */
; 114  :         have = strm->avail_out;

  0015c	8b 4d f8	 mov	 ecx, DWORD PTR _strm$[ebp]
  0015f	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00162	89 55 fc	 mov	 DWORD PTR _have$[ebp], edx

; 115  :         ret = deflate(strm, flush);

  00165	8b 45 0c	 mov	 eax, DWORD PTR _flush$[ebp]
  00168	50		 push	 eax
  00169	8b 4d f8	 mov	 ecx, DWORD PTR _strm$[ebp]
  0016c	51		 push	 ecx
  0016d	e8 00 00 00 00	 call	 _deflate@8
  00172	89 45 f4	 mov	 DWORD PTR _ret$[ebp], eax

; 116  :         if (ret == Z_STREAM_ERROR) {

  00175	83 7d f4 fe	 cmp	 DWORD PTR _ret$[ebp], -2 ; fffffffeH
  00179	75 18		 jne	 SHORT $LN2@gz_comp

; 117  :             gz_error(state, Z_STREAM_ERROR,
; 118  :                       "internal error: deflate stream corrupt");

  0017b	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5c@
  00180	6a fe		 push	 -2			; fffffffeH
  00182	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00185	52		 push	 edx
  00186	e8 00 00 00 00	 call	 _gz_error
  0018b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 119  :             return -1;

  0018e	83 c8 ff	 or	 eax, -1
  00191	eb 23		 jmp	 SHORT $LN16@gz_comp
$LN2@gz_comp:

; 120  :         }
; 121  :         have -= strm->avail_out;

  00193	8b 45 f8	 mov	 eax, DWORD PTR _strm$[ebp]
  00196	8b 4d fc	 mov	 ecx, DWORD PTR _have$[ebp]
  00199	2b 48 10	 sub	 ecx, DWORD PTR [eax+16]
  0019c	89 4d fc	 mov	 DWORD PTR _have$[ebp], ecx

; 122  :     } while (have);

  0019f	0f 85 04 ff ff
	ff		 jne	 $LN11@gz_comp

; 123  : 
; 124  :     /* if that completed a deflate stream, allow another to start */
; 125  :     if (flush == Z_FINISH)

  001a5	83 7d 0c 04	 cmp	 DWORD PTR _flush$[ebp], 4
  001a9	75 09		 jne	 SHORT $LN1@gz_comp

; 126  :         deflateReset(strm);

  001ab	8b 55 f8	 mov	 edx, DWORD PTR _strm$[ebp]
  001ae	52		 push	 edx
  001af	e8 00 00 00 00	 call	 _deflateReset@4
$LN1@gz_comp:

; 127  : 
; 128  :     /* all done, no errors */
; 129  :     return 0;

  001b4	33 c0		 xor	 eax, eax
$LN16@gz_comp:

; 130  : }

  001b6	8b e5		 mov	 esp, ebp
  001b8	5d		 pop	 ebp
  001b9	c3		 ret	 0
_gz_comp ENDP
; Function compile flags: /Odtp
;	COMDAT _gz_zero
_TEXT	SEGMENT
tv78 = -24						; size = 4
tv140 = -20						; size = 8
_strm$ = -12						; size = 4
_n$ = -8						; size = 4
_first$ = -4						; size = 4
_state$ = 8						; size = 4
_len$ = 12						; size = 8
_gz_zero PROC						; COMDAT

; 136  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 137  :     int first;
; 138  :     unsigned n;
; 139  :     z_streamp strm = &(state->strm);

  00006	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00009	83 c0 64	 add	 eax, 100		; 00000064H
  0000c	89 45 f4	 mov	 DWORD PTR _strm$[ebp], eax

; 140  : 
; 141  :     /* consume whatever's left in the input buffer */
; 142  :     if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)

  0000f	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  00012	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00016	74 1b		 je	 SHORT $LN5@gz_zero
  00018	6a 00		 push	 0
  0001a	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0001d	52		 push	 edx
  0001e	e8 00 00 00 00	 call	 _gz_comp
  00023	83 c4 08	 add	 esp, 8
  00026	83 f8 ff	 cmp	 eax, -1
  00029	75 08		 jne	 SHORT $LN5@gz_zero

; 143  :         return -1;

  0002b	83 c8 ff	 or	 eax, -1
  0002e	e9 d1 00 00 00	 jmp	 $LN6@gz_zero
$LN5@gz_zero:

; 144  : 
; 145  :     /* compress len zeros (len guaranteed > 0) */
; 146  :     first = 1;

  00033	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _first$[ebp], 1
$LN4@gz_zero:

; 147  :     while (len) {

  0003a	8b 45 0c	 mov	 eax, DWORD PTR _len$[ebp]
  0003d	0b 45 10	 or	 eax, DWORD PTR _len$[ebp+4]
  00040	0f 84 bc 00 00
	00		 je	 $LN3@gz_zero

; 148  :         n = GT_OFF(state->size) || (z_off64_t)state->size > len ?
; 149  :             (unsigned)len : state->size;

  00046	33 c9		 xor	 ecx, ecx
  00048	75 2b		 jne	 SHORT $LN8@gz_zero
  0004a	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0004d	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00050	33 c9		 xor	 ecx, ecx
  00052	89 45 ec	 mov	 DWORD PTR tv140[ebp], eax
  00055	89 4d f0	 mov	 DWORD PTR tv140[ebp+4], ecx
  00058	8b 55 f0	 mov	 edx, DWORD PTR tv140[ebp+4]
  0005b	3b 55 10	 cmp	 edx, DWORD PTR _len$[ebp+4]
  0005e	7f 15		 jg	 SHORT $LN8@gz_zero
  00060	7c 08		 jl	 SHORT $LN10@gz_zero
  00062	8b 45 ec	 mov	 eax, DWORD PTR tv140[ebp]
  00065	3b 45 0c	 cmp	 eax, DWORD PTR _len$[ebp]
  00068	77 0b		 ja	 SHORT $LN8@gz_zero
$LN10@gz_zero:
  0006a	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0006d	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00070	89 55 e8	 mov	 DWORD PTR tv78[ebp], edx
  00073	eb 06		 jmp	 SHORT $LN9@gz_zero
$LN8@gz_zero:
  00075	8b 45 0c	 mov	 eax, DWORD PTR _len$[ebp]
  00078	89 45 e8	 mov	 DWORD PTR tv78[ebp], eax
$LN9@gz_zero:
  0007b	8b 4d e8	 mov	 ecx, DWORD PTR tv78[ebp]
  0007e	89 4d f8	 mov	 DWORD PTR _n$[ebp], ecx

; 150  :         if (first) {

  00081	83 7d fc 00	 cmp	 DWORD PTR _first$[ebp], 0
  00085	74 1c		 je	 SHORT $LN2@gz_zero

; 151  :             memset(state->in, 0, n);

  00087	8b 55 f8	 mov	 edx, DWORD PTR _n$[ebp]
  0008a	52		 push	 edx
  0008b	6a 00		 push	 0
  0008d	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00090	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00093	51		 push	 ecx
  00094	e8 00 00 00 00	 call	 _memset
  00099	83 c4 0c	 add	 esp, 12			; 0000000cH

; 152  :             first = 0;

  0009c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _first$[ebp], 0
$LN2@gz_zero:

; 153  :         }
; 154  :         strm->avail_in = n;

  000a3	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  000a6	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  000a9	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 155  :         strm->next_in = state->in;

  000ac	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  000af	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000b2	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  000b5	89 01		 mov	 DWORD PTR [ecx], eax

; 156  :         state->x.pos += n;

  000b7	8b 4d f8	 mov	 ecx, DWORD PTR _n$[ebp]
  000ba	33 d2		 xor	 edx, edx
  000bc	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000bf	03 48 08	 add	 ecx, DWORD PTR [eax+8]
  000c2	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  000c5	13 c2		 adc	 eax, edx
  000c7	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000ca	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  000cd	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 157  :         if (gz_comp(state, Z_NO_FLUSH) == -1)

  000d0	6a 00		 push	 0
  000d2	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000d5	50		 push	 eax
  000d6	e8 00 00 00 00	 call	 _gz_comp
  000db	83 c4 08	 add	 esp, 8
  000de	83 f8 ff	 cmp	 eax, -1
  000e1	75 05		 jne	 SHORT $LN1@gz_zero

; 158  :             return -1;

  000e3	83 c8 ff	 or	 eax, -1
  000e6	eb 1c		 jmp	 SHORT $LN6@gz_zero
$LN1@gz_zero:

; 159  :         len -= n;

  000e8	8b 4d f8	 mov	 ecx, DWORD PTR _n$[ebp]
  000eb	33 d2		 xor	 edx, edx
  000ed	8b 45 0c	 mov	 eax, DWORD PTR _len$[ebp]
  000f0	2b c1		 sub	 eax, ecx
  000f2	8b 4d 10	 mov	 ecx, DWORD PTR _len$[ebp+4]
  000f5	1b ca		 sbb	 ecx, edx
  000f7	89 45 0c	 mov	 DWORD PTR _len$[ebp], eax
  000fa	89 4d 10	 mov	 DWORD PTR _len$[ebp+4], ecx

; 160  :     }

  000fd	e9 38 ff ff ff	 jmp	 $LN4@gz_zero
$LN3@gz_zero:

; 161  :     return 0;

  00102	33 c0		 xor	 eax, eax
$LN6@gz_zero:

; 162  : }

  00104	8b e5		 mov	 esp, ebp
  00106	5d		 pop	 ebp
  00107	c3		 ret	 0
_gz_zero ENDP
PUBLIC	_gzclose_w@4
; Function compile flags: /Odtp
;	COMDAT _gzclose_w@4
_TEXT	SEGMENT
_state$ = -8						; size = 4
_ret$ = -4						; size = 4
_file$ = 8						; size = 4
_gzclose_w@4 PROC					; COMDAT

; 529  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 530  :     int ret = Z_OK;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 0

; 531  :     gz_statep state;
; 532  : 
; 533  :     /* get internal structure */
; 534  :     if (file == NULL)

  0000d	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  00011	75 0a		 jne	 SHORT $LN8@gzclose_w

; 535  :         return Z_STREAM_ERROR;

  00013	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00018	e9 f5 00 00 00	 jmp	 $LN9@gzclose_w
$LN8@gzclose_w:

; 536  :     state = (gz_statep)file;

  0001d	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00020	89 45 f8	 mov	 DWORD PTR _state$[ebp], eax

; 537  : 
; 538  :     /* check that we're writing */
; 539  :     if (state->mode != GZ_WRITE)

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  00026	81 79 10 b1 79
	00 00		 cmp	 DWORD PTR [ecx+16], 31153 ; 000079b1H
  0002d	74 0a		 je	 SHORT $LN7@gzclose_w

; 540  :         return Z_STREAM_ERROR;

  0002f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00034	e9 d9 00 00 00	 jmp	 $LN9@gzclose_w
$LN7@gzclose_w:

; 541  : 
; 542  :     /* check for seek request */
; 543  :     if (state->seek) {

  00039	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  0003c	83 7a 58 00	 cmp	 DWORD PTR [edx+88], 0
  00040	74 2f		 je	 SHORT $LN6@gzclose_w

; 544  :         state->seek = 0;

  00042	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  00045	c7 40 58 00 00
	00 00		 mov	 DWORD PTR [eax+88], 0

; 545  :         if (gz_zero(state, state->skip) == -1)

  0004c	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  0004f	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  00052	52		 push	 edx
  00053	8b 41 50	 mov	 eax, DWORD PTR [ecx+80]
  00056	50		 push	 eax
  00057	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  0005a	51		 push	 ecx
  0005b	e8 00 00 00 00	 call	 _gz_zero
  00060	83 c4 0c	 add	 esp, 12			; 0000000cH
  00063	83 f8 ff	 cmp	 eax, -1
  00066	75 09		 jne	 SHORT $LN6@gzclose_w

; 546  :             ret = state->err;

  00068	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  0006b	8b 42 5c	 mov	 eax, DWORD PTR [edx+92]
  0006e	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax
$LN6@gzclose_w:

; 547  :     }
; 548  : 
; 549  :     /* flush, free memory, and close file */
; 550  :     if (state->size) {

  00071	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  00074	83 79 1c 00	 cmp	 DWORD PTR [ecx+28], 0
  00078	74 4f		 je	 SHORT $LN4@gzclose_w

; 551  :         if (gz_comp(state, Z_FINISH) == -1)

  0007a	6a 04		 push	 4
  0007c	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  0007f	52		 push	 edx
  00080	e8 00 00 00 00	 call	 _gz_comp
  00085	83 c4 08	 add	 esp, 8
  00088	83 f8 ff	 cmp	 eax, -1
  0008b	75 09		 jne	 SHORT $LN3@gzclose_w

; 552  :             ret = state->err;

  0008d	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  00090	8b 48 5c	 mov	 ecx, DWORD PTR [eax+92]
  00093	89 4d fc	 mov	 DWORD PTR _ret$[ebp], ecx
$LN3@gzclose_w:

; 553  :         if (!state->direct) {

  00096	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  00099	83 7a 2c 00	 cmp	 DWORD PTR [edx+44], 0
  0009d	75 1b		 jne	 SHORT $LN2@gzclose_w

; 554  :             (void)deflateEnd(&(state->strm));

  0009f	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  000a2	83 c0 64	 add	 eax, 100		; 00000064H
  000a5	50		 push	 eax
  000a6	e8 00 00 00 00	 call	 _deflateEnd@4

; 555  :             free(state->out);

  000ab	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  000ae	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  000b1	52		 push	 edx
  000b2	e8 00 00 00 00	 call	 _free
  000b7	83 c4 04	 add	 esp, 4
$LN2@gzclose_w:

; 556  :         }
; 557  :         free(state->in);

  000ba	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  000bd	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  000c0	51		 push	 ecx
  000c1	e8 00 00 00 00	 call	 _free
  000c6	83 c4 04	 add	 esp, 4
$LN4@gzclose_w:

; 558  :     }
; 559  :     gz_error(state, Z_OK, NULL);

  000c9	6a 00		 push	 0
  000cb	6a 00		 push	 0
  000cd	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  000d0	52		 push	 edx
  000d1	e8 00 00 00 00	 call	 _gz_error
  000d6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 560  :     free(state->path);

  000d9	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  000dc	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000df	51		 push	 ecx
  000e0	e8 00 00 00 00	 call	 _free
  000e5	83 c4 04	 add	 esp, 4

; 561  :     if (close(state->fd) == -1)

  000e8	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  000eb	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  000ee	50		 push	 eax
  000ef	e8 00 00 00 00	 call	 _close
  000f4	83 c4 04	 add	 esp, 4
  000f7	83 f8 ff	 cmp	 eax, -1
  000fa	75 07		 jne	 SHORT $LN1@gzclose_w

; 562  :         ret = Z_ERRNO;

  000fc	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -1
$LN1@gzclose_w:

; 563  :     free(state);

  00103	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  00106	51		 push	 ecx
  00107	e8 00 00 00 00	 call	 _free
  0010c	83 c4 04	 add	 esp, 4

; 564  :     return ret;

  0010f	8b 45 fc	 mov	 eax, DWORD PTR _ret$[ebp]
$LN9@gzclose_w:

; 565  : }

  00112	8b e5		 mov	 esp, ebp
  00114	5d		 pop	 ebp
  00115	c2 04 00	 ret	 4
_gzclose_w@4 ENDP
_TEXT	ENDS
PUBLIC	_gzsetparams@12
; Function compile flags: /Odtp
;	COMDAT _gzsetparams@12
_TEXT	SEGMENT
_state$ = -8						; size = 4
_strm$ = -4						; size = 4
_file$ = 8						; size = 4
_level$ = 12						; size = 4
_strategy$ = 16						; size = 4
_gzsetparams@12 PROC					; COMDAT

; 489  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 490  :     gz_statep state;
; 491  :     z_streamp strm;
; 492  : 
; 493  :     /* get internal structure */
; 494  :     if (file == NULL)

  00006	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  0000a	75 0a		 jne	 SHORT $LN8@gzsetparam

; 495  :         return Z_STREAM_ERROR;

  0000c	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00011	e9 d1 00 00 00	 jmp	 $LN9@gzsetparam
$LN8@gzsetparam:

; 496  :     state = (gz_statep)file;

  00016	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00019	89 45 f8	 mov	 DWORD PTR _state$[ebp], eax

; 497  :     strm = &(state->strm);

  0001c	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  0001f	83 c1 64	 add	 ecx, 100		; 00000064H
  00022	89 4d fc	 mov	 DWORD PTR _strm$[ebp], ecx

; 498  : 
; 499  :     /* check that we're writing and that there's no error */
; 500  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00025	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  00028	81 7a 10 b1 79
	00 00		 cmp	 DWORD PTR [edx+16], 31153 ; 000079b1H
  0002f	75 09		 jne	 SHORT $LN6@gzsetparam
  00031	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  00034	83 78 5c 00	 cmp	 DWORD PTR [eax+92], 0
  00038	74 0a		 je	 SHORT $LN7@gzsetparam
$LN6@gzsetparam:

; 501  :         return Z_STREAM_ERROR;

  0003a	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0003f	e9 a3 00 00 00	 jmp	 $LN9@gzsetparam
$LN7@gzsetparam:

; 502  : 
; 503  :     /* if no change is requested, then do nothing */
; 504  :     if (level == state->level && strategy == state->strategy)

  00044	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  00047	8b 55 0c	 mov	 edx, DWORD PTR _level$[ebp]
  0004a	3b 51 48	 cmp	 edx, DWORD PTR [ecx+72]
  0004d	75 12		 jne	 SHORT $LN5@gzsetparam
  0004f	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  00052	8b 4d 10	 mov	 ecx, DWORD PTR _strategy$[ebp]
  00055	3b 48 4c	 cmp	 ecx, DWORD PTR [eax+76]
  00058	75 07		 jne	 SHORT $LN5@gzsetparam

; 505  :         return Z_OK;

  0005a	33 c0		 xor	 eax, eax
  0005c	e9 86 00 00 00	 jmp	 $LN9@gzsetparam
$LN5@gzsetparam:

; 506  : 
; 507  :     /* check for seek request */
; 508  :     if (state->seek) {

  00061	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  00064	83 7a 58 00	 cmp	 DWORD PTR [edx+88], 0
  00068	74 2b		 je	 SHORT $LN4@gzsetparam

; 509  :         state->seek = 0;

  0006a	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  0006d	c7 40 58 00 00
	00 00		 mov	 DWORD PTR [eax+88], 0

; 510  :         if (gz_zero(state, state->skip) == -1)

  00074	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  00077	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  0007a	52		 push	 edx
  0007b	8b 41 50	 mov	 eax, DWORD PTR [ecx+80]
  0007e	50		 push	 eax
  0007f	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  00082	51		 push	 ecx
  00083	e8 00 00 00 00	 call	 _gz_zero
  00088	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008b	83 f8 ff	 cmp	 eax, -1
  0008e	75 05		 jne	 SHORT $LN4@gzsetparam

; 511  :             return -1;

  00090	83 c8 ff	 or	 eax, -1
  00093	eb 52		 jmp	 SHORT $LN9@gzsetparam
$LN4@gzsetparam:

; 512  :     }
; 513  : 
; 514  :     /* change compression parameters for subsequent input */
; 515  :     if (state->size) {

  00095	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  00098	83 7a 1c 00	 cmp	 DWORD PTR [edx+28], 0
  0009c	74 35		 je	 SHORT $LN2@gzsetparam

; 516  :         /* flush previous input with previous parameters before changing */
; 517  :         if (strm->avail_in && gz_comp(state, Z_PARTIAL_FLUSH) == -1)

  0009e	8b 45 fc	 mov	 eax, DWORD PTR _strm$[ebp]
  000a1	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  000a5	74 1b		 je	 SHORT $LN1@gzsetparam
  000a7	6a 01		 push	 1
  000a9	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  000ac	51		 push	 ecx
  000ad	e8 00 00 00 00	 call	 _gz_comp
  000b2	83 c4 08	 add	 esp, 8
  000b5	83 f8 ff	 cmp	 eax, -1
  000b8	75 08		 jne	 SHORT $LN1@gzsetparam

; 518  :             return state->err;

  000ba	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  000bd	8b 42 5c	 mov	 eax, DWORD PTR [edx+92]
  000c0	eb 25		 jmp	 SHORT $LN9@gzsetparam
$LN1@gzsetparam:

; 519  :         deflateParams(strm, level, strategy);

  000c2	8b 45 10	 mov	 eax, DWORD PTR _strategy$[ebp]
  000c5	50		 push	 eax
  000c6	8b 4d 0c	 mov	 ecx, DWORD PTR _level$[ebp]
  000c9	51		 push	 ecx
  000ca	8b 55 fc	 mov	 edx, DWORD PTR _strm$[ebp]
  000cd	52		 push	 edx
  000ce	e8 00 00 00 00	 call	 _deflateParams@12
$LN2@gzsetparam:

; 520  :     }
; 521  :     state->level = level;

  000d3	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  000d6	8b 4d 0c	 mov	 ecx, DWORD PTR _level$[ebp]
  000d9	89 48 48	 mov	 DWORD PTR [eax+72], ecx

; 522  :     state->strategy = strategy;

  000dc	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  000df	8b 45 10	 mov	 eax, DWORD PTR _strategy$[ebp]
  000e2	89 42 4c	 mov	 DWORD PTR [edx+76], eax

; 523  :     return Z_OK;

  000e5	33 c0		 xor	 eax, eax
$LN9@gzsetparam:

; 524  : }

  000e7	8b e5		 mov	 esp, ebp
  000e9	5d		 pop	 ebp
  000ea	c2 0c 00	 ret	 12			; 0000000cH
_gzsetparams@12 ENDP
_TEXT	ENDS
PUBLIC	_gzflush@8
; Function compile flags: /Odtp
;	COMDAT _gzflush@8
_TEXT	SEGMENT
_state$ = -4						; size = 4
_file$ = 8						; size = 4
_flush$ = 12						; size = 4
_gzflush@8 PROC						; COMDAT

; 456  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 457  :     gz_statep state;
; 458  : 
; 459  :     /* get internal structure */
; 460  :     if (file == NULL)

  00004	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  00008	75 05		 jne	 SHORT $LN7@gzflush

; 461  :         return -1;

  0000a	83 c8 ff	 or	 eax, -1
  0000d	eb 7f		 jmp	 SHORT $LN8@gzflush
$LN7@gzflush:

; 462  :     state = (gz_statep)file;

  0000f	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax

; 463  : 
; 464  :     /* check that we're writing and that there's no error */
; 465  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00018	81 79 10 b1 79
	00 00		 cmp	 DWORD PTR [ecx+16], 31153 ; 000079b1H
  0001f	75 09		 jne	 SHORT $LN5@gzflush
  00021	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00024	83 7a 5c 00	 cmp	 DWORD PTR [edx+92], 0
  00028	74 07		 je	 SHORT $LN6@gzflush
$LN5@gzflush:

; 466  :         return Z_STREAM_ERROR;

  0002a	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0002f	eb 5d		 jmp	 SHORT $LN8@gzflush
$LN6@gzflush:

; 467  : 
; 468  :     /* check flush parameter */
; 469  :     if (flush < 0 || flush > Z_FINISH)

  00031	83 7d 0c 00	 cmp	 DWORD PTR _flush$[ebp], 0
  00035	7c 06		 jl	 SHORT $LN3@gzflush
  00037	83 7d 0c 04	 cmp	 DWORD PTR _flush$[ebp], 4
  0003b	7e 07		 jle	 SHORT $LN4@gzflush
$LN3@gzflush:

; 470  :         return Z_STREAM_ERROR;

  0003d	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00042	eb 4a		 jmp	 SHORT $LN8@gzflush
$LN4@gzflush:

; 471  : 
; 472  :     /* check for seek request */
; 473  :     if (state->seek) {

  00044	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00047	83 78 58 00	 cmp	 DWORD PTR [eax+88], 0
  0004b	74 2b		 je	 SHORT $LN2@gzflush

; 474  :         state->seek = 0;

  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00050	c7 41 58 00 00
	00 00		 mov	 DWORD PTR [ecx+88], 0

; 475  :         if (gz_zero(state, state->skip) == -1)

  00057	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0005a	8b 42 54	 mov	 eax, DWORD PTR [edx+84]
  0005d	50		 push	 eax
  0005e	8b 4a 50	 mov	 ecx, DWORD PTR [edx+80]
  00061	51		 push	 ecx
  00062	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00065	52		 push	 edx
  00066	e8 00 00 00 00	 call	 _gz_zero
  0006b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006e	83 f8 ff	 cmp	 eax, -1
  00071	75 05		 jne	 SHORT $LN2@gzflush

; 476  :             return -1;

  00073	83 c8 ff	 or	 eax, -1
  00076	eb 16		 jmp	 SHORT $LN8@gzflush
$LN2@gzflush:

; 477  :     }
; 478  : 
; 479  :     /* compress remaining data with requested flush */
; 480  :     gz_comp(state, flush);

  00078	8b 45 0c	 mov	 eax, DWORD PTR _flush$[ebp]
  0007b	50		 push	 eax
  0007c	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0007f	51		 push	 ecx
  00080	e8 00 00 00 00	 call	 _gz_comp
  00085	83 c4 08	 add	 esp, 8

; 481  :     return state->err;

  00088	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0008b	8b 42 5c	 mov	 eax, DWORD PTR [edx+92]
$LN8@gzflush:

; 482  : }

  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c2 08 00	 ret	 8
_gzflush@8 ENDP
_TEXT	ENDS
PUBLIC	_gzprintf
; Function compile flags: /Odtp
;	COMDAT _gzprintf
_TEXT	SEGMENT
_state$ = -20						; size = 4
_size$ = -16						; size = 4
_len$ = -12						; size = 4
_strm$ = -8						; size = 4
_va$ = -4						; size = 4
_file$ = 8						; size = 4
_format$ = 12						; size = 4
_gzprintf PROC						; COMDAT

; 304  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 305  :     int size, len;
; 306  :     gz_statep state;
; 307  :     z_streamp strm;
; 308  :     va_list va;
; 309  : 
; 310  :     /* get internal structure */
; 311  :     if (file == NULL)

  00006	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  0000a	75 08		 jne	 SHORT $LN9@gzprintf

; 312  :         return -1;

  0000c	83 c8 ff	 or	 eax, -1
  0000f	e9 3a 01 00 00	 jmp	 $LN10@gzprintf
$LN9@gzprintf:

; 313  :     state = (gz_statep)file;

  00014	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00017	89 45 ec	 mov	 DWORD PTR _state$[ebp], eax

; 314  :     strm = &(state->strm);

  0001a	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  0001d	83 c1 64	 add	 ecx, 100		; 00000064H
  00020	89 4d f8	 mov	 DWORD PTR _strm$[ebp], ecx

; 315  : 
; 316  :     /* check that we're writing and that there's no error */
; 317  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00023	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  00026	81 7a 10 b1 79
	00 00		 cmp	 DWORD PTR [edx+16], 31153 ; 000079b1H
  0002d	75 09		 jne	 SHORT $LN7@gzprintf
  0002f	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  00032	83 78 5c 00	 cmp	 DWORD PTR [eax+92], 0
  00036	74 07		 je	 SHORT $LN8@gzprintf
$LN7@gzprintf:

; 318  :         return 0;

  00038	33 c0		 xor	 eax, eax
  0003a	e9 0f 01 00 00	 jmp	 $LN10@gzprintf
$LN8@gzprintf:

; 319  : 
; 320  :     /* make sure we have some buffer space */
; 321  :     if (state->size == 0 && gz_init(state) == -1)

  0003f	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  00042	83 79 1c 00	 cmp	 DWORD PTR [ecx+28], 0
  00046	75 18		 jne	 SHORT $LN6@gzprintf
  00048	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  0004b	52		 push	 edx
  0004c	e8 00 00 00 00	 call	 _gz_init
  00051	83 c4 04	 add	 esp, 4
  00054	83 f8 ff	 cmp	 eax, -1
  00057	75 07		 jne	 SHORT $LN6@gzprintf

; 322  :         return 0;

  00059	33 c0		 xor	 eax, eax
  0005b	e9 ee 00 00 00	 jmp	 $LN10@gzprintf
$LN6@gzprintf:

; 323  : 
; 324  :     /* check for seek request */
; 325  :     if (state->seek) {

  00060	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  00063	83 78 58 00	 cmp	 DWORD PTR [eax+88], 0
  00067	74 2d		 je	 SHORT $LN5@gzprintf

; 326  :         state->seek = 0;

  00069	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  0006c	c7 41 58 00 00
	00 00		 mov	 DWORD PTR [ecx+88], 0

; 327  :         if (gz_zero(state, state->skip) == -1)

  00073	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  00076	8b 42 54	 mov	 eax, DWORD PTR [edx+84]
  00079	50		 push	 eax
  0007a	8b 4a 50	 mov	 ecx, DWORD PTR [edx+80]
  0007d	51		 push	 ecx
  0007e	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  00081	52		 push	 edx
  00082	e8 00 00 00 00	 call	 _gz_zero
  00087	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008a	83 f8 ff	 cmp	 eax, -1
  0008d	75 07		 jne	 SHORT $LN5@gzprintf

; 328  :             return 0;

  0008f	33 c0		 xor	 eax, eax
  00091	e9 b8 00 00 00	 jmp	 $LN10@gzprintf
$LN5@gzprintf:

; 329  :     }
; 330  : 
; 331  :     /* consume whatever's left in the input buffer */
; 332  :     if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)

  00096	8b 45 f8	 mov	 eax, DWORD PTR _strm$[ebp]
  00099	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0009d	74 1a		 je	 SHORT $LN3@gzprintf
  0009f	6a 00		 push	 0
  000a1	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  000a4	51		 push	 ecx
  000a5	e8 00 00 00 00	 call	 _gz_comp
  000aa	83 c4 08	 add	 esp, 8
  000ad	83 f8 ff	 cmp	 eax, -1
  000b0	75 07		 jne	 SHORT $LN3@gzprintf

; 333  :         return 0;

  000b2	33 c0		 xor	 eax, eax
  000b4	e9 95 00 00 00	 jmp	 $LN10@gzprintf
$LN3@gzprintf:

; 334  : 
; 335  :     /* do the printf() into the input buffer, put length in len */
; 336  :     size = (int)(state->size);

  000b9	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  000bc	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  000bf	89 45 f0	 mov	 DWORD PTR _size$[ebp], eax

; 337  :     state->in[size - 1] = 0;

  000c2	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  000c5	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  000c8	8b 45 f0	 mov	 eax, DWORD PTR _size$[ebp]
  000cb	c6 44 10 ff 00	 mov	 BYTE PTR [eax+edx-1], 0

; 338  :     va_start(va, format);

  000d0	8d 4d 10	 lea	 ecx, DWORD PTR _format$[ebp+4]
  000d3	89 4d fc	 mov	 DWORD PTR _va$[ebp], ecx

; 339  : #ifdef NO_vsnprintf
; 340  : #  ifdef HAS_vsprintf_void
; 341  :     (void)vsprintf((char *)(state->in), format, va);
; 342  :     va_end(va);
; 343  :     for (len = 0; len < size; len++)
; 344  :         if (state->in[len] == 0) break;
; 345  : #  else
; 346  :     len = vsprintf((char *)(state->in), format, va);
; 347  :     va_end(va);
; 348  : #  endif
; 349  : #else
; 350  : #  ifdef HAS_vsnprintf_void
; 351  :     (void)vsnprintf((char *)(state->in), size, format, va);
; 352  :     va_end(va);
; 353  :     len = strlen((char *)(state->in));
; 354  : #  else
; 355  :     len = vsnprintf((char *)(state->in), size, format, va);

  000d6	8b 55 fc	 mov	 edx, DWORD PTR _va$[ebp]
  000d9	52		 push	 edx
  000da	8b 45 0c	 mov	 eax, DWORD PTR _format$[ebp]
  000dd	50		 push	 eax
  000de	8b 4d f0	 mov	 ecx, DWORD PTR _size$[ebp]
  000e1	51		 push	 ecx
  000e2	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  000e5	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  000e8	50		 push	 eax
  000e9	e8 00 00 00 00	 call	 _vsnprintf
  000ee	83 c4 10	 add	 esp, 16			; 00000010H
  000f1	89 45 f4	 mov	 DWORD PTR _len$[ebp], eax

; 356  :     va_end(va);

  000f4	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _va$[ebp], 0

; 357  : #  endif
; 358  : #endif
; 359  : 
; 360  :     /* check that printf() results fit in buffer */
; 361  :     if (len <= 0 || len >= (int)size || state->in[size - 1] != 0)

  000fb	83 7d f4 00	 cmp	 DWORD PTR _len$[ebp], 0
  000ff	7e 1a		 jle	 SHORT $LN1@gzprintf
  00101	8b 4d f4	 mov	 ecx, DWORD PTR _len$[ebp]
  00104	3b 4d f0	 cmp	 ecx, DWORD PTR _size$[ebp]
  00107	7d 12		 jge	 SHORT $LN1@gzprintf
  00109	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  0010c	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  0010f	8b 4d f0	 mov	 ecx, DWORD PTR _size$[ebp]
  00112	0f b6 54 08 ff	 movzx	 edx, BYTE PTR [eax+ecx-1]
  00117	85 d2		 test	 edx, edx
  00119	74 04		 je	 SHORT $LN2@gzprintf
$LN1@gzprintf:

; 362  :         return 0;

  0011b	33 c0		 xor	 eax, eax
  0011d	eb 2f		 jmp	 SHORT $LN10@gzprintf
$LN2@gzprintf:

; 363  : 
; 364  :     /* update buffer and position, defer compression until needed */
; 365  :     strm->avail_in = (unsigned)len;

  0011f	8b 45 f8	 mov	 eax, DWORD PTR _strm$[ebp]
  00122	8b 4d f4	 mov	 ecx, DWORD PTR _len$[ebp]
  00125	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 366  :     strm->next_in = state->in;

  00128	8b 55 f8	 mov	 edx, DWORD PTR _strm$[ebp]
  0012b	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  0012e	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00131	89 0a		 mov	 DWORD PTR [edx], ecx

; 367  :     state->x.pos += len;

  00133	8b 45 f4	 mov	 eax, DWORD PTR _len$[ebp]
  00136	99		 cdq
  00137	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  0013a	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  0013d	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00140	13 ca		 adc	 ecx, edx
  00142	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  00145	89 42 08	 mov	 DWORD PTR [edx+8], eax
  00148	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 368  :     return len;

  0014b	8b 45 f4	 mov	 eax, DWORD PTR _len$[ebp]
$LN10@gzprintf:

; 369  : }

  0014e	8b e5		 mov	 esp, ebp
  00150	5d		 pop	 ebp
  00151	c3		 ret	 0
_gzprintf ENDP
_TEXT	ENDS
PUBLIC	_gzwrite@12
; Function compile flags: /Odtp
;	COMDAT _gzwrite@12
_TEXT	SEGMENT
_state$ = -16						; size = 4
_strm$ = -12						; size = 4
_n$ = -8						; size = 4
_put$ = -4						; size = 4
_file$ = 8						; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
_gzwrite@12 PROC					; COMDAT

; 169  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 170  :     unsigned put = len;

  00006	8b 45 10	 mov	 eax, DWORD PTR _len$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR _put$[ebp], eax

; 171  :     unsigned n;
; 172  :     gz_statep state;
; 173  :     z_streamp strm;
; 174  : 
; 175  :     /* get internal structure */
; 176  :     if (file == NULL)

  0000c	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  00010	75 07		 jne	 SHORT $LN18@gzwrite

; 177  :         return 0;

  00012	33 c0		 xor	 eax, eax
  00014	e9 ce 01 00 00	 jmp	 $LN19@gzwrite
$LN18@gzwrite:

; 178  :     state = (gz_statep)file;

  00019	8b 4d 08	 mov	 ecx, DWORD PTR _file$[ebp]
  0001c	89 4d f0	 mov	 DWORD PTR _state$[ebp], ecx

; 179  :     strm = &(state->strm);

  0001f	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00022	83 c2 64	 add	 edx, 100		; 00000064H
  00025	89 55 f4	 mov	 DWORD PTR _strm$[ebp], edx

; 180  : 
; 181  :     /* check that we're writing and that there's no error */
; 182  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00028	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  0002b	81 78 10 b1 79
	00 00		 cmp	 DWORD PTR [eax+16], 31153 ; 000079b1H
  00032	75 09		 jne	 SHORT $LN16@gzwrite
  00034	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00037	83 79 5c 00	 cmp	 DWORD PTR [ecx+92], 0
  0003b	74 07		 je	 SHORT $LN17@gzwrite
$LN16@gzwrite:

; 183  :         return 0;

  0003d	33 c0		 xor	 eax, eax
  0003f	e9 a3 01 00 00	 jmp	 $LN19@gzwrite
$LN17@gzwrite:

; 184  : 
; 185  :     /* since an int is returned, make sure len fits in one, otherwise return
; 186  :        with an error (this avoids the flaw in the interface) */
; 187  :     if ((int)len < 0) {

  00044	83 7d 10 00	 cmp	 DWORD PTR _len$[ebp], 0
  00048	7d 1a		 jge	 SHORT $LN15@gzwrite

; 188  :         gz_error(state, Z_DATA_ERROR, "requested length does not fit in int");

  0004a	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5in@
  0004f	6a fd		 push	 -3			; fffffffdH
  00051	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00054	52		 push	 edx
  00055	e8 00 00 00 00	 call	 _gz_error
  0005a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 189  :         return 0;

  0005d	33 c0		 xor	 eax, eax
  0005f	e9 83 01 00 00	 jmp	 $LN19@gzwrite
$LN15@gzwrite:

; 190  :     }
; 191  : 
; 192  :     /* if len is zero, avoid unnecessary operations */
; 193  :     if (len == 0)

  00064	83 7d 10 00	 cmp	 DWORD PTR _len$[ebp], 0
  00068	75 07		 jne	 SHORT $LN14@gzwrite

; 194  :         return 0;

  0006a	33 c0		 xor	 eax, eax
  0006c	e9 76 01 00 00	 jmp	 $LN19@gzwrite
$LN14@gzwrite:

; 195  : 
; 196  :     /* allocate memory if this is the first time through */
; 197  :     if (state->size == 0 && gz_init(state) == -1)

  00071	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00074	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00078	75 18		 jne	 SHORT $LN13@gzwrite
  0007a	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  0007d	51		 push	 ecx
  0007e	e8 00 00 00 00	 call	 _gz_init
  00083	83 c4 04	 add	 esp, 4
  00086	83 f8 ff	 cmp	 eax, -1
  00089	75 07		 jne	 SHORT $LN13@gzwrite

; 198  :         return 0;

  0008b	33 c0		 xor	 eax, eax
  0008d	e9 55 01 00 00	 jmp	 $LN19@gzwrite
$LN13@gzwrite:

; 199  : 
; 200  :     /* check for seek request */
; 201  :     if (state->seek) {

  00092	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00095	83 7a 58 00	 cmp	 DWORD PTR [edx+88], 0
  00099	74 2d		 je	 SHORT $LN12@gzwrite

; 202  :         state->seek = 0;

  0009b	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  0009e	c7 40 58 00 00
	00 00		 mov	 DWORD PTR [eax+88], 0

; 203  :         if (gz_zero(state, state->skip) == -1)

  000a5	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  000a8	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  000ab	52		 push	 edx
  000ac	8b 41 50	 mov	 eax, DWORD PTR [ecx+80]
  000af	50		 push	 eax
  000b0	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  000b3	51		 push	 ecx
  000b4	e8 00 00 00 00	 call	 _gz_zero
  000b9	83 c4 0c	 add	 esp, 12			; 0000000cH
  000bc	83 f8 ff	 cmp	 eax, -1
  000bf	75 07		 jne	 SHORT $LN12@gzwrite

; 204  :             return 0;

  000c1	33 c0		 xor	 eax, eax
  000c3	e9 1f 01 00 00	 jmp	 $LN19@gzwrite
$LN12@gzwrite:

; 205  :     }
; 206  : 
; 207  :     /* for small len, copy to input buffer, otherwise compress directly */
; 208  :     if (len < state->size) {

  000c8	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  000cb	8b 45 10	 mov	 eax, DWORD PTR _len$[ebp]
  000ce	3b 42 1c	 cmp	 eax, DWORD PTR [edx+28]
  000d1	0f 83 ac 00 00
	00		 jae	 $LN10@gzwrite
$LN9@gzwrite:

; 209  :         /* copy to input buffer, compress when full */
; 210  :         do {
; 211  :             if (strm->avail_in == 0)

  000d7	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  000da	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  000de	75 0b		 jne	 SHORT $LN6@gzwrite

; 212  :                 strm->next_in = state->in;

  000e0	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  000e3	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  000e6	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  000e9	89 0a		 mov	 DWORD PTR [edx], ecx
$LN6@gzwrite:

; 213  :             n = state->size - strm->avail_in;

  000eb	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  000ee	8b 45 f4	 mov	 eax, DWORD PTR _strm$[ebp]
  000f1	8b 4a 1c	 mov	 ecx, DWORD PTR [edx+28]
  000f4	2b 48 04	 sub	 ecx, DWORD PTR [eax+4]
  000f7	89 4d f8	 mov	 DWORD PTR _n$[ebp], ecx

; 214  :             if (n > len)

  000fa	8b 55 f8	 mov	 edx, DWORD PTR _n$[ebp]
  000fd	3b 55 10	 cmp	 edx, DWORD PTR _len$[ebp]
  00100	76 06		 jbe	 SHORT $LN5@gzwrite

; 215  :                 n = len;

  00102	8b 45 10	 mov	 eax, DWORD PTR _len$[ebp]
  00105	89 45 f8	 mov	 DWORD PTR _n$[ebp], eax
$LN5@gzwrite:

; 216  :             memcpy(strm->next_in + strm->avail_in, buf, n);

  00108	8b 4d f8	 mov	 ecx, DWORD PTR _n$[ebp]
  0010b	51		 push	 ecx
  0010c	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  0010f	52		 push	 edx
  00110	8b 45 f4	 mov	 eax, DWORD PTR _strm$[ebp]
  00113	8b 08		 mov	 ecx, DWORD PTR [eax]
  00115	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  00118	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  0011b	51		 push	 ecx
  0011c	e8 00 00 00 00	 call	 _memcpy
  00121	83 c4 0c	 add	 esp, 12			; 0000000cH

; 217  :             strm->avail_in += n;

  00124	8b 45 f4	 mov	 eax, DWORD PTR _strm$[ebp]
  00127	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0012a	03 4d f8	 add	 ecx, DWORD PTR _n$[ebp]
  0012d	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  00130	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 218  :             state->x.pos += n;

  00133	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  00136	33 c9		 xor	 ecx, ecx
  00138	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  0013b	03 42 08	 add	 eax, DWORD PTR [edx+8]
  0013e	8b 52 0c	 mov	 edx, DWORD PTR [edx+12]
  00141	13 d1		 adc	 edx, ecx
  00143	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00146	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00149	89 51 0c	 mov	 DWORD PTR [ecx+12], edx

; 219  :             buf = (char *)buf + n;

  0014c	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  0014f	03 55 f8	 add	 edx, DWORD PTR _n$[ebp]
  00152	89 55 0c	 mov	 DWORD PTR _buf$[ebp], edx

; 220  :             len -= n;

  00155	8b 45 10	 mov	 eax, DWORD PTR _len$[ebp]
  00158	2b 45 f8	 sub	 eax, DWORD PTR _n$[ebp]
  0015b	89 45 10	 mov	 DWORD PTR _len$[ebp], eax

; 221  :             if (len && gz_comp(state, Z_NO_FLUSH) == -1)

  0015e	74 17		 je	 SHORT $LN8@gzwrite
  00160	6a 00		 push	 0
  00162	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00165	51		 push	 ecx
  00166	e8 00 00 00 00	 call	 _gz_comp
  0016b	83 c4 08	 add	 esp, 8
  0016e	83 f8 ff	 cmp	 eax, -1
  00171	75 04		 jne	 SHORT $LN8@gzwrite

; 222  :                 return 0;

  00173	33 c0		 xor	 eax, eax
  00175	eb 70		 jmp	 SHORT $LN19@gzwrite
$LN8@gzwrite:

; 223  :         } while (len);

  00177	83 7d 10 00	 cmp	 DWORD PTR _len$[ebp], 0
  0017b	0f 85 56 ff ff
	ff		 jne	 $LN9@gzwrite

; 224  :     }
; 225  :     else {

  00181	eb 61		 jmp	 SHORT $LN3@gzwrite
$LN10@gzwrite:

; 226  :         /* consume whatever's left in the input buffer */
; 227  :         if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)

  00183	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  00186	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  0018a	74 17		 je	 SHORT $LN2@gzwrite
  0018c	6a 00		 push	 0
  0018e	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00191	50		 push	 eax
  00192	e8 00 00 00 00	 call	 _gz_comp
  00197	83 c4 08	 add	 esp, 8
  0019a	83 f8 ff	 cmp	 eax, -1
  0019d	75 04		 jne	 SHORT $LN2@gzwrite

; 228  :             return 0;

  0019f	33 c0		 xor	 eax, eax
  001a1	eb 44		 jmp	 SHORT $LN19@gzwrite
$LN2@gzwrite:

; 229  : 
; 230  :         /* directly compress user buffer to file */
; 231  :         strm->avail_in = len;

  001a3	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  001a6	8b 55 10	 mov	 edx, DWORD PTR _len$[ebp]
  001a9	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 232  :         strm->next_in = (voidp)buf;

  001ac	8b 45 f4	 mov	 eax, DWORD PTR _strm$[ebp]
  001af	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  001b2	89 08		 mov	 DWORD PTR [eax], ecx

; 233  :         state->x.pos += len;

  001b4	8b 55 10	 mov	 edx, DWORD PTR _len$[ebp]
  001b7	33 c0		 xor	 eax, eax
  001b9	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  001bc	03 51 08	 add	 edx, DWORD PTR [ecx+8]
  001bf	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  001c2	13 c8		 adc	 ecx, eax
  001c4	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  001c7	89 50 08	 mov	 DWORD PTR [eax+8], edx
  001ca	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 234  :         if (gz_comp(state, Z_NO_FLUSH) == -1)

  001cd	6a 00		 push	 0
  001cf	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  001d2	51		 push	 ecx
  001d3	e8 00 00 00 00	 call	 _gz_comp
  001d8	83 c4 08	 add	 esp, 8
  001db	83 f8 ff	 cmp	 eax, -1
  001de	75 04		 jne	 SHORT $LN3@gzwrite

; 235  :             return 0;

  001e0	33 c0		 xor	 eax, eax
  001e2	eb 03		 jmp	 SHORT $LN19@gzwrite
$LN3@gzwrite:

; 236  :     }
; 237  : 
; 238  :     /* input was all buffered or compressed (put will fit in int) */
; 239  :     return (int)put;

  001e4	8b 45 fc	 mov	 eax, DWORD PTR _put$[ebp]
$LN19@gzwrite:

; 240  : }

  001e7	8b e5		 mov	 esp, ebp
  001e9	5d		 pop	 ebp
  001ea	c2 0c 00	 ret	 12			; 0000000cH
_gzwrite@12 ENDP
PUBLIC	_gzputs@8
; Function compile flags: /Odtp
;	COMDAT _gzputs@8
_TEXT	SEGMENT
tv72 = -12						; size = 4
_ret$ = -8						; size = 4
_len$ = -4						; size = 4
_file$ = 8						; size = 4
_str$ = 12						; size = 4
_gzputs@8 PROC						; COMDAT

; 289  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 290  :     int ret;
; 291  :     unsigned len;
; 292  : 
; 293  :     /* write string */
; 294  :     len = (unsigned)strlen(str);

  00006	8b 45 0c	 mov	 eax, DWORD PTR _str$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _strlen
  0000f	83 c4 04	 add	 esp, 4
  00012	89 45 fc	 mov	 DWORD PTR _len$[ebp], eax

; 295  :     ret = gzwrite(file, str, len);

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _len$[ebp]
  00018	51		 push	 ecx
  00019	8b 55 0c	 mov	 edx, DWORD PTR _str$[ebp]
  0001c	52		 push	 edx
  0001d	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 _gzwrite@12
  00026	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax

; 296  :     return ret == 0 && len != 0 ? -1 : ret;

  00029	83 7d f8 00	 cmp	 DWORD PTR _ret$[ebp], 0
  0002d	75 0f		 jne	 SHORT $LN3@gzputs
  0002f	83 7d fc 00	 cmp	 DWORD PTR _len$[ebp], 0
  00033	74 09		 je	 SHORT $LN3@gzputs
  00035	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR tv72[ebp], -1
  0003c	eb 06		 jmp	 SHORT $LN4@gzputs
$LN3@gzputs:
  0003e	8b 4d f8	 mov	 ecx, DWORD PTR _ret$[ebp]
  00041	89 4d f4	 mov	 DWORD PTR tv72[ebp], ecx
$LN4@gzputs:
  00044	8b 45 f4	 mov	 eax, DWORD PTR tv72[ebp]

; 297  : }

  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 08 00	 ret	 8
_gzputs@8 ENDP
_TEXT	ENDS
PUBLIC	_gzputc@8
; Function compile flags: /Odtp
;	COMDAT _gzputc@8
_TEXT	SEGMENT
_state$ = -12						; size = 4
_buf$ = -5						; size = 1
_strm$ = -4						; size = 4
_file$ = 8						; size = 4
_c$ = 12						; size = 4
_gzputc@8 PROC						; COMDAT

; 246  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 247  :     unsigned char buf[1];
; 248  :     gz_statep state;
; 249  :     z_streamp strm;
; 250  : 
; 251  :     /* get internal structure */
; 252  :     if (file == NULL)

  00006	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  0000a	75 08		 jne	 SHORT $LN8@gzputc

; 253  :         return -1;

  0000c	83 c8 ff	 or	 eax, -1
  0000f	e9 ee 00 00 00	 jmp	 $LN9@gzputc
$LN8@gzputc:

; 254  :     state = (gz_statep)file;

  00014	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00017	89 45 f4	 mov	 DWORD PTR _state$[ebp], eax

; 255  :     strm = &(state->strm);

  0001a	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  0001d	83 c1 64	 add	 ecx, 100		; 00000064H
  00020	89 4d fc	 mov	 DWORD PTR _strm$[ebp], ecx

; 256  : 
; 257  :     /* check that we're writing and that there's no error */
; 258  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00023	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  00026	81 7a 10 b1 79
	00 00		 cmp	 DWORD PTR [edx+16], 31153 ; 000079b1H
  0002d	75 09		 jne	 SHORT $LN6@gzputc
  0002f	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  00032	83 78 5c 00	 cmp	 DWORD PTR [eax+92], 0
  00036	74 08		 je	 SHORT $LN7@gzputc
$LN6@gzputc:

; 259  :         return -1;

  00038	83 c8 ff	 or	 eax, -1
  0003b	e9 c2 00 00 00	 jmp	 $LN9@gzputc
$LN7@gzputc:

; 260  : 
; 261  :     /* check for seek request */
; 262  :     if (state->seek) {

  00040	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  00043	83 79 58 00	 cmp	 DWORD PTR [ecx+88], 0
  00047	74 2e		 je	 SHORT $LN5@gzputc

; 263  :         state->seek = 0;

  00049	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  0004c	c7 42 58 00 00
	00 00		 mov	 DWORD PTR [edx+88], 0

; 264  :         if (gz_zero(state, state->skip) == -1)

  00053	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  00056	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  00059	51		 push	 ecx
  0005a	8b 50 50	 mov	 edx, DWORD PTR [eax+80]
  0005d	52		 push	 edx
  0005e	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 _gz_zero
  00067	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006a	83 f8 ff	 cmp	 eax, -1
  0006d	75 08		 jne	 SHORT $LN5@gzputc

; 265  :             return -1;

  0006f	83 c8 ff	 or	 eax, -1
  00072	e9 8b 00 00 00	 jmp	 $LN9@gzputc
$LN5@gzputc:

; 266  :     }
; 267  : 
; 268  :     /* try writing to input buffer for speed (state->size == 0 if buffer not
; 269  :        initialized) */
; 270  :     if (strm->avail_in < state->size) {

  00077	8b 4d fc	 mov	 ecx, DWORD PTR _strm$[ebp]
  0007a	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  0007d	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00080	3b 42 1c	 cmp	 eax, DWORD PTR [edx+28]
  00083	73 56		 jae	 SHORT $LN3@gzputc

; 271  :         if (strm->avail_in == 0)

  00085	8b 4d fc	 mov	 ecx, DWORD PTR _strm$[ebp]
  00088	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  0008c	75 0b		 jne	 SHORT $LN2@gzputc

; 272  :             strm->next_in = state->in;

  0008e	8b 55 fc	 mov	 edx, DWORD PTR _strm$[ebp]
  00091	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  00094	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00097	89 0a		 mov	 DWORD PTR [edx], ecx
$LN2@gzputc:

; 273  :         strm->next_in[strm->avail_in++] = c;

  00099	8b 55 fc	 mov	 edx, DWORD PTR _strm$[ebp]
  0009c	8b 02		 mov	 eax, DWORD PTR [edx]
  0009e	8b 4d fc	 mov	 ecx, DWORD PTR _strm$[ebp]
  000a1	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000a4	8a 4d 0c	 mov	 cl, BYTE PTR _c$[ebp]
  000a7	88 0c 10	 mov	 BYTE PTR [eax+edx], cl
  000aa	8b 55 fc	 mov	 edx, DWORD PTR _strm$[ebp]
  000ad	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000b0	83 c0 01	 add	 eax, 1
  000b3	8b 4d fc	 mov	 ecx, DWORD PTR _strm$[ebp]
  000b6	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 274  :         state->x.pos++;

  000b9	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  000bc	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000bf	83 c0 01	 add	 eax, 1
  000c2	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  000c5	83 d1 00	 adc	 ecx, 0
  000c8	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  000cb	89 42 08	 mov	 DWORD PTR [edx+8], eax
  000ce	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 275  :         return c & 0xff;

  000d1	8b 45 0c	 mov	 eax, DWORD PTR _c$[ebp]
  000d4	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000d9	eb 27		 jmp	 SHORT $LN9@gzputc
$LN3@gzputc:

; 276  :     }
; 277  : 
; 278  :     /* no room in buffer or not initialized, use gz_write() */
; 279  :     buf[0] = c;

  000db	8a 45 0c	 mov	 al, BYTE PTR _c$[ebp]
  000de	88 45 fb	 mov	 BYTE PTR _buf$[ebp], al

; 280  :     if (gzwrite(file, buf, 1) != 1)

  000e1	6a 01		 push	 1
  000e3	8d 4d fb	 lea	 ecx, DWORD PTR _buf$[ebp]
  000e6	51		 push	 ecx
  000e7	8b 55 08	 mov	 edx, DWORD PTR _file$[ebp]
  000ea	52		 push	 edx
  000eb	e8 00 00 00 00	 call	 _gzwrite@12
  000f0	83 f8 01	 cmp	 eax, 1
  000f3	74 05		 je	 SHORT $LN1@gzputc

; 281  :         return -1;

  000f5	83 c8 ff	 or	 eax, -1
  000f8	eb 08		 jmp	 SHORT $LN9@gzputc
$LN1@gzputc:

; 282  :     return c & 0xff;

  000fa	8b 45 0c	 mov	 eax, DWORD PTR _c$[ebp]
  000fd	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
$LN9@gzputc:

; 283  : }

  00102	8b e5		 mov	 esp, ebp
  00104	5d		 pop	 ebp
  00105	c2 08 00	 ret	 8
_gzputc@8 ENDP
END
