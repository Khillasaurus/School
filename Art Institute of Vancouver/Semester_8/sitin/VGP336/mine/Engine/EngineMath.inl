//====================================================================================================
// Filename:	EngineMath.inl
// Created by:	Peter Chan
//====================================================================================================

namespace Math
{

//====================================================================================================
// Function Definitions
//====================================================================================================

template <typename T>
inline T Min(T a, T b)
{
	return (a > b) ? b : a;
}

//----------------------------------------------------------------------------------------------------

template <typename T>
inline T Max(T a, T b)
{
	return (a < b) ? b : a;
}

//----------------------------------------------------------------------------------------------------

template <typename T>
inline T Clamp(T value, T min, T max)
{
	return Max(min, Min(max, value));
}

//----------------------------------------------------------------------------------------------------

inline f32 Abs(f32 value)
{
	return (value >= 0.0f) ? value : -value;
}

//----------------------------------------------------------------------------------------------------

inline f32 Sign(f32 value)
{
	return (value >= 0.0f) ? 1.0f : -1.0f;
}

//----------------------------------------------------------------------------------------------------

inline f32 Sqr(f32 value)
{
	return value * value;
}

//----------------------------------------------------------------------------------------------------

inline f32 Sqrt(f32 value)
{
	ASSERT(value >= 0.0f, "[Math] Cannot square root a negative number!");
	return sqrt(value);
}

//----------------------------------------------------------------------------------------------------

inline bool Compare(f32 a, f32 b, f32 epsilon)
{
	return Abs(a - b) < epsilon;
}

//----------------------------------------------------------------------------------------------------

inline bool IsZero(f32 value)
{
	return Compare(value, 0.0f);
}

//----------------------------------------------------------------------------------------------------

inline bool IsZero(const Vector3& v)
{
	return IsZero(v.x) && IsZero(v.y) && IsZero(v.z);
}

//----------------------------------------------------------------------------------------------------

inline f32 MagnitudeSqr(const Vector3& v)
{
	return (v.x * v.x) + (v.y * v.y) + (v.z * v.z);
}

//----------------------------------------------------------------------------------------------------

inline f32 Magnitude(const Vector3& v)
{
	return Sqrt(MagnitudeSqr(v));
}

//----------------------------------------------------------------------------------------------------

inline Vector3 Normalize(const Vector3& v)
{
	ASSERT(!IsZero(v), "[Math] Cannot normalize zero length vector!");
	const f32 inv = 1.0f / Magnitude(v);
	return v * inv;
}

//----------------------------------------------------------------------------------------------------

inline Quaternion Normalize(const Quaternion& q)
{
	const f32 magSqr = (q.x * q.x) + (q.y * q.y) + (q.z * q.z) + (q.w * q.w);
	const f32 magInv = 1.0f / sqrt(magSqr);
	return q * magInv;
}

//----------------------------------------------------------------------------------------------------

inline f32 DistanceSqr(const Vector3& a, const Vector3& b)
{
	return MagnitudeSqr(a - b);
}

//----------------------------------------------------------------------------------------------------

inline f32 Distance(const Vector3& a, const Vector3& b)
{
	return Sqrt(DistanceSqr(a, b));
}

//----------------------------------------------------------------------------------------------------

inline f32 Dot(const Vector3& a, const Vector3& b)
{
	return (a.x * b.x) + (a.y * b.y) + (a.z * b.z);
}

//----------------------------------------------------------------------------------------------------

inline Vector3 Cross(const Vector3& a, const Vector3& b)
{
	return Vector3
	(
		(a.y * b.z) - (a.z * b.y),
		(a.z * b.x) - (a.x * b.z),
		(a.x * b.y) - (a.y * b.x)
	);
}

//----------------------------------------------------------------------------------------------------

inline Vector3 Project(const Vector3& v, const Vector3& n)
{
	return n * (Dot(v, n) / Dot(n, n));
}

//----------------------------------------------------------------------------------------------------

inline f32 Determinant(const Matrix& m)
{
	f32 det = 0.0f;
	det  = (m._11 * (m._22 * (m._33 * m._44 - (m._43 * m._34)) - m._23 * (m._32 * m._44 - (m._42 * m._34)) + m._24 * (m._32 * m._43 - (m._42 * m._33))));
	det -= (m._12 * (m._21 * (m._33 * m._44 - (m._43 * m._34)) - m._23 * (m._31 * m._44 - (m._41 * m._34)) + m._24 * (m._31 * m._43 - (m._41 * m._33))));
	det += (m._13 * (m._21 * (m._32 * m._44 - (m._42 * m._34)) - m._22 * (m._31 * m._44 - (m._41 * m._34)) + m._24 * (m._31 * m._42 - (m._41 * m._32))));
	det -= (m._14 * (m._21 * (m._32 * m._43 - (m._42 * m._33)) - m._22 * (m._31 * m._43 - (m._41 * m._33)) + m._23 * (m._31 * m._42 - (m._41 * m._32))));
	return det;
}

//----------------------------------------------------------------------------------------------------

inline Matrix Adjoint(const Matrix& m)
{
	return Matrix
	(
		 (m._22 * ((m._33 * m._44) - (m._43 * m._34)) - m._23 * ((m._32 * m._44) - (m._42 * m._34)) + m._24 * ((m._32 * m._43) - (m._42 * m._33))),
		-(m._12 * ((m._33 * m._44) - (m._43 * m._34)) - m._13 * ((m._32 * m._44) - (m._42 * m._34)) + m._14 * ((m._32 * m._43) - (m._42 * m._33))),
		 (m._12 * ((m._23 * m._44) - (m._43 * m._24)) - m._13 * ((m._22 * m._44) - (m._42 * m._24)) + m._14 * ((m._22 * m._43) - (m._42 * m._23))),
		-(m._12 * ((m._23 * m._34) - (m._33 * m._24)) - m._13 * ((m._22 * m._34) - (m._32 * m._24)) + m._14 * ((m._22 * m._33) - (m._32 * m._23))),

		-(m._21 * ((m._33 * m._44) - (m._43 * m._34)) - m._31 * ((m._23 * m._44) - (m._24 * m._43)) + m._41 * ((m._23 * m._34) - (m._24 * m._33))),
		 (m._11 * ((m._33 * m._44) - (m._43 * m._34)) - m._13 * ((m._31 * m._44) - (m._41 * m._34)) + m._14 * ((m._31 * m._43) - (m._41 * m._33))),
		-(m._11 * ((m._23 * m._44) - (m._43 * m._24)) - m._13 * ((m._21 * m._44) - (m._41 * m._24)) + m._14 * ((m._21 * m._43) - (m._41 * m._23))),
		 (m._11 * ((m._23 * m._34) - (m._33 * m._24)) - m._13 * ((m._21 * m._34) - (m._31 * m._24)) + m._14 * ((m._21 * m._33) - (m._31 * m._23))),

		 (m._21 * ((m._32 * m._44) - (m._42 * m._34)) - m._31 * ((m._22 * m._44) - (m._42 * m._24)) + m._41 * ((m._22 * m._34) - (m._32 * m._24))),
		-(m._11 * ((m._32 * m._44) - (m._42 * m._34)) - m._31 * ((m._12 * m._44) - (m._42 * m._14)) + m._41 * ((m._12 * m._34) - (m._32 * m._14))),
		 (m._11 * ((m._22 * m._44) - (m._42 * m._24)) - m._12 * ((m._21 * m._44) - (m._41 * m._24)) + m._14 * ((m._21 * m._42) - (m._41 * m._22))),
		-(m._11 * ((m._22 * m._34) - (m._32 * m._24)) - m._21 * ((m._12 * m._34) - (m._32 * m._14)) + m._31 * ((m._12 * m._24) - (m._22 * m._14))),

		-(m._21 * ((m._32 * m._43) - (m._42 * m._33)) - m._31 * ((m._22 * m._43) - (m._42 * m._23)) + m._41 * ((m._22 * m._33) - (m._32 * m._23))),
		 (m._11 * ((m._32 * m._43) - (m._42 * m._33)) - m._12 * ((m._31 * m._43) - (m._41 * m._33)) + m._13 * ((m._31 * m._42) - (m._41 * m._32))),
		-(m._11 * ((m._22 * m._43) - (m._42 * m._23)) - m._12 * ((m._21 * m._43) - (m._41 * m._23)) + m._13 * ((m._21 * m._42) - (m._41 * m._22))),
		 (m._11 * ((m._22 * m._33) - (m._32 * m._23)) - m._12 * ((m._21 * m._33) - (m._31 * m._23)) + m._13 * ((m._21 * m._32) - (m._31 * m._22)))
	);
}

//----------------------------------------------------------------------------------------------------

inline Matrix Inverse(const Matrix& m)
{
	const f32 determinant = Determinant(m);
	ASSERT(!IsZero(determinant), "[Math] Cannot find the inverse of matrix. Determinant equals 0.0!");
	const f32 invDet = 1.0f / determinant;
	return Adjoint(m) * invDet;
}

//----------------------------------------------------------------------------------------------------

inline Matrix Transpose(const Matrix& m)
{
	return Matrix
	(
		m._11, m._21, m._31, m._41,
		m._12, m._22, m._32, m._42,
		m._13, m._23, m._33, m._43,
		m._14, m._24, m._34, m._44
	);
}

//----------------------------------------------------------------------------------------------------

inline Vector3 TransformCoord(const Vector3& v, const Matrix& m)
{
	return Vector3
	(
		v.x * m._11 + v.y * m._21 + v.z * m._31 + m._41,
		v.x * m._12 + v.y * m._22 + v.z * m._32 + m._42,
		v.x * m._13 + v.y * m._23 + v.z * m._33 + m._43
	);
}

//----------------------------------------------------------------------------------------------------

inline Vector3 TransformNormal(const Vector3& v, const Matrix& m)
{
	return Vector3
	(
		v.x * m._11 + v.y * m._21 + v.z * m._31,
		v.x * m._12 + v.y * m._22 + v.z * m._32,
		v.x * m._13 + v.y * m._23 + v.z * m._33
	);
}

//----------------------------------------------------------------------------------------------------

inline Vector3 Lerp(const Vector3& v0, const Vector3& v1, f32 t)
{
	return v0 + ((v1 - v0) * t);
}

//----------------------------------------------------------------------------------------------------

inline Quaternion Lerp(Quaternion q0, Quaternion q1, f32 t)
{
	return q0 * (1.0f - t) + (q1 * t);
}

} // namespace Math