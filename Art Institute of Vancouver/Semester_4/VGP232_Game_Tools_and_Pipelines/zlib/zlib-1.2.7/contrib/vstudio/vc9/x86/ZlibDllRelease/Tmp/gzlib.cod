; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.21022.08 

	TITLE	f:\Semester 4\VGP232 Game Tools & Pipelines\zlib\zlib-1.2.7\gzlib.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO?$AA@		; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@		; `string'
PUBLIC	??_C@_02LMMGGCAJ@?3?5?$AA@			; `string'
EXTRN	_sprintf:PROC
EXTRN	_wcstombs:PROC
EXTRN	__wopen:PROC
EXTRN	_open:PROC
EXTRN	__lseeki64:PROC
EXTRN	_strcpy:PROC
EXTRN	_strcat:PROC
EXTRN	_strlen:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
;	COMDAT ??_C@_02LMMGGCAJ@?3?5?$AA@
CONST	SEGMENT
??_C@_02LMMGGCAJ@?3?5?$AA@ DB ': ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
CONST	SEGMENT
??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@ DB 'out of memory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO?$AA@
CONST	SEGMENT
??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO?$AA@ DB '<fd:%d>', 00H ; `string'
PUBLIC	_gz_error
; Function compile flags: /Odtp
; File f:\semester 4\vgp232 game tools & pipelines\zlib\zlib-1.2.7\gzlib.c
;	COMDAT _gz_error
_TEXT	SEGMENT
_state$ = 8						; size = 4
_err$ = 12						; size = 4
_msg$ = 16						; size = 4
_gz_error PROC						; COMDAT

; 568  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 569  :     /* free previously allocated message and clear */
; 570  :     if (state->msg != NULL) {

  00004	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00007	83 78 60 00	 cmp	 DWORD PTR [eax+96], 0
  0000b	74 22		 je	 SHORT $LN6@gz_error

; 571  :         if (state->err != Z_MEM_ERROR)

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00010	83 79 5c fc	 cmp	 DWORD PTR [ecx+92], -4	; fffffffcH
  00014	74 0f		 je	 SHORT $LN5@gz_error

; 572  :             free(state->msg);

  00016	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00019	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 _free
  00022	83 c4 04	 add	 esp, 4
$LN5@gz_error:

; 573  :         state->msg = NULL;

  00025	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00028	c7 41 60 00 00
	00 00		 mov	 DWORD PTR [ecx+96], 0
$LN6@gz_error:

; 574  :     }
; 575  : 
; 576  :     /* if fatal, set state->x.have to 0 so that the gzgetc() macro fails */
; 577  :     if (err != Z_OK && err != Z_BUF_ERROR)

  0002f	83 7d 0c 00	 cmp	 DWORD PTR _err$[ebp], 0
  00033	74 0f		 je	 SHORT $LN4@gz_error
  00035	83 7d 0c fb	 cmp	 DWORD PTR _err$[ebp], -5 ; fffffffbH
  00039	74 09		 je	 SHORT $LN4@gz_error

; 578  :         state->x.have = 0;

  0003b	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0003e	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
$LN4@gz_error:

; 579  : 
; 580  :     /* set error code, and if no message, then done */
; 581  :     state->err = err;

  00044	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00047	8b 4d 0c	 mov	 ecx, DWORD PTR _err$[ebp]
  0004a	89 48 5c	 mov	 DWORD PTR [eax+92], ecx

; 582  :     if (msg == NULL)

  0004d	83 7d 10 00	 cmp	 DWORD PTR _msg$[ebp], 0
  00051	75 05		 jne	 SHORT $LN3@gz_error

; 583  :         return;

  00053	e9 a0 00 00 00	 jmp	 $LN7@gz_error
$LN3@gz_error:

; 584  : 
; 585  :     /* for an out of memory error, save as static string */
; 586  :     if (err == Z_MEM_ERROR) {

  00058	83 7d 0c fc	 cmp	 DWORD PTR _err$[ebp], -4 ; fffffffcH
  0005c	75 0e		 jne	 SHORT $LN2@gz_error

; 587  :         state->msg = (char *)msg;

  0005e	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00061	8b 45 10	 mov	 eax, DWORD PTR _msg$[ebp]
  00064	89 42 60	 mov	 DWORD PTR [edx+96], eax

; 588  :         return;

  00067	e9 8c 00 00 00	 jmp	 $LN7@gz_error
$LN2@gz_error:

; 589  :     }
; 590  : 
; 591  :     /* construct error message with path */
; 592  :     if ((state->msg = malloc(strlen(state->path) + strlen(msg) + 3)) == NULL) {

  0006c	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0006f	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00072	52		 push	 edx
  00073	e8 00 00 00 00	 call	 _strlen
  00078	83 c4 04	 add	 esp, 4
  0007b	8b f0		 mov	 esi, eax
  0007d	8b 45 10	 mov	 eax, DWORD PTR _msg$[ebp]
  00080	50		 push	 eax
  00081	e8 00 00 00 00	 call	 _strlen
  00086	83 c4 04	 add	 esp, 4
  00089	8d 4c 06 03	 lea	 ecx, DWORD PTR [esi+eax+3]
  0008d	51		 push	 ecx
  0008e	e8 00 00 00 00	 call	 _malloc
  00093	83 c4 04	 add	 esp, 4
  00096	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00099	89 42 60	 mov	 DWORD PTR [edx+96], eax
  0009c	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0009f	83 78 60 00	 cmp	 DWORD PTR [eax+96], 0
  000a3	75 16		 jne	 SHORT $LN1@gz_error

; 593  :         state->err = Z_MEM_ERROR;

  000a5	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  000a8	c7 41 5c fc ff
	ff ff		 mov	 DWORD PTR [ecx+92], -4	; fffffffcH

; 594  :         state->msg = (char *)"out of memory";

  000af	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000b2	c7 42 60 00 00
	00 00		 mov	 DWORD PTR [edx+96], OFFSET ??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@

; 595  :         return;

  000b9	eb 3d		 jmp	 SHORT $LN7@gz_error
$LN1@gz_error:

; 596  :     }
; 597  :     strcpy(state->msg, state->path);

  000bb	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000be	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000c1	51		 push	 ecx
  000c2	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000c5	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  000c8	50		 push	 eax
  000c9	e8 00 00 00 00	 call	 _strcpy
  000ce	83 c4 08	 add	 esp, 8

; 598  :     strcat(state->msg, ": ");

  000d1	68 00 00 00 00	 push	 OFFSET ??_C@_02LMMGGCAJ@?3?5?$AA@
  000d6	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  000d9	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  000dc	52		 push	 edx
  000dd	e8 00 00 00 00	 call	 _strcat
  000e2	83 c4 08	 add	 esp, 8

; 599  :     strcat(state->msg, msg);

  000e5	8b 45 10	 mov	 eax, DWORD PTR _msg$[ebp]
  000e8	50		 push	 eax
  000e9	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  000ec	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  000ef	52		 push	 edx
  000f0	e8 00 00 00 00	 call	 _strcat
  000f5	83 c4 08	 add	 esp, 8
$LN7@gz_error:

; 600  :     return;
; 601  : }

  000f8	5e		 pop	 esi
  000f9	5d		 pop	 ebp
  000fa	c3		 ret	 0
_gz_error ENDP
_TEXT	ENDS
PUBLIC	_gzclearerr@4
; Function compile flags: /Odtp
;	COMDAT _gzclearerr@4
_TEXT	SEGMENT
_state$ = -4						; size = 4
_file$ = 8						; size = 4
_gzclearerr@4 PROC					; COMDAT

; 540  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 541  :     gz_statep state;
; 542  : 
; 543  :     /* get internal structure and check integrity */
; 544  :     if (file == NULL)

  00004	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  00008	75 02		 jne	 SHORT $LN3@gzclearerr

; 545  :         return;

  0000a	eb 50		 jmp	 SHORT $LN4@gzclearerr
$LN3@gzclearerr:

; 546  :     state = (gz_statep)file;

  0000c	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax

; 547  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00012	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00015	81 79 10 4f 1c
	00 00		 cmp	 DWORD PTR [ecx+16], 7247 ; 00001c4fH
  0001c	74 0e		 je	 SHORT $LN2@gzclearerr
  0001e	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00021	81 7a 10 b1 79
	00 00		 cmp	 DWORD PTR [edx+16], 31153 ; 000079b1H
  00028	74 02		 je	 SHORT $LN2@gzclearerr

; 548  :         return;

  0002a	eb 30		 jmp	 SHORT $LN4@gzclearerr
$LN2@gzclearerr:

; 549  : 
; 550  :     /* clear error and end-of-file */
; 551  :     if (state->mode == GZ_READ) {

  0002c	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0002f	81 78 10 4f 1c
	00 00		 cmp	 DWORD PTR [eax+16], 7247 ; 00001c4fH
  00036	75 14		 jne	 SHORT $LN1@gzclearerr

; 552  :         state->eof = 0;

  00038	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0003b	c7 41 40 00 00
	00 00		 mov	 DWORD PTR [ecx+64], 0

; 553  :         state->past = 0;

  00042	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00045	c7 42 44 00 00
	00 00		 mov	 DWORD PTR [edx+68], 0
$LN1@gzclearerr:

; 554  :     }
; 555  :     gz_error(state, Z_OK, NULL);

  0004c	6a 00		 push	 0
  0004e	6a 00		 push	 0
  00050	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 _gz_error
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@gzclearerr:

; 556  : }

  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c2 04 00	 ret	 4
_gzclearerr@4 ENDP
_TEXT	ENDS
PUBLIC	_gzerror@8
; Function compile flags: /Odtp
;	COMDAT _gzerror@8
_TEXT	SEGMENT
tv74 = -8						; size = 4
_state$ = -4						; size = 4
_file$ = 8						; size = 4
_errnum$ = 12						; size = 4
_gzerror@8 PROC						; COMDAT

; 521  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 522  :     gz_statep state;
; 523  : 
; 524  :     /* get internal structure and check integrity */
; 525  :     if (file == NULL)

  00006	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  0000a	75 04		 jne	 SHORT $LN3@gzerror

; 526  :         return NULL;

  0000c	33 c0		 xor	 eax, eax
  0000e	eb 51		 jmp	 SHORT $LN4@gzerror
$LN3@gzerror:

; 527  :     state = (gz_statep)file;

  00010	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00013	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax

; 528  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00016	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00019	81 79 10 4f 1c
	00 00		 cmp	 DWORD PTR [ecx+16], 7247 ; 00001c4fH
  00020	74 10		 je	 SHORT $LN2@gzerror
  00022	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00025	81 7a 10 b1 79
	00 00		 cmp	 DWORD PTR [edx+16], 31153 ; 000079b1H
  0002c	74 04		 je	 SHORT $LN2@gzerror

; 529  :         return NULL;

  0002e	33 c0		 xor	 eax, eax
  00030	eb 2f		 jmp	 SHORT $LN4@gzerror
$LN2@gzerror:

; 530  : 
; 531  :     /* return error information */
; 532  :     if (errnum != NULL)

  00032	83 7d 0c 00	 cmp	 DWORD PTR _errnum$[ebp], 0
  00036	74 0b		 je	 SHORT $LN1@gzerror

; 533  :         *errnum = state->err;

  00038	8b 45 0c	 mov	 eax, DWORD PTR _errnum$[ebp]
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0003e	8b 51 5c	 mov	 edx, DWORD PTR [ecx+92]
  00041	89 10		 mov	 DWORD PTR [eax], edx
$LN1@gzerror:

; 534  :     return state->msg == NULL ? "" : state->msg;

  00043	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00046	83 78 60 00	 cmp	 DWORD PTR [eax+96], 0
  0004a	75 09		 jne	 SHORT $LN6@gzerror
  0004c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
  00053	eb 09		 jmp	 SHORT $LN7@gzerror
$LN6@gzerror:
  00055	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00058	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  0005b	89 55 f8	 mov	 DWORD PTR tv74[ebp], edx
$LN7@gzerror:
  0005e	8b 45 f8	 mov	 eax, DWORD PTR tv74[ebp]
$LN4@gzerror:

; 535  : }

  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 08 00	 ret	 8
_gzerror@8 ENDP
_TEXT	ENDS
PUBLIC	_gzeof@4
; Function compile flags: /Odtp
;	COMDAT _gzeof@4
_TEXT	SEGMENT
tv72 = -8						; size = 4
_state$ = -4						; size = 4
_file$ = 8						; size = 4
_gzeof@4 PROC						; COMDAT

; 503  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 504  :     gz_statep state;
; 505  : 
; 506  :     /* get internal structure and check integrity */
; 507  :     if (file == NULL)

  00006	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  0000a	75 04		 jne	 SHORT $LN2@gzeof

; 508  :         return 0;

  0000c	33 c0		 xor	 eax, eax
  0000e	eb 43		 jmp	 SHORT $LN3@gzeof
$LN2@gzeof:

; 509  :     state = (gz_statep)file;

  00010	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00013	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax

; 510  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00016	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00019	81 79 10 4f 1c
	00 00		 cmp	 DWORD PTR [ecx+16], 7247 ; 00001c4fH
  00020	74 10		 je	 SHORT $LN1@gzeof
  00022	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00025	81 7a 10 b1 79
	00 00		 cmp	 DWORD PTR [edx+16], 31153 ; 000079b1H
  0002c	74 04		 je	 SHORT $LN1@gzeof

; 511  :         return 0;

  0002e	33 c0		 xor	 eax, eax
  00030	eb 21		 jmp	 SHORT $LN3@gzeof
$LN1@gzeof:

; 512  : 
; 513  :     /* return end-of-file state */
; 514  :     return state->mode == GZ_READ ? state->past : 0;

  00032	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00035	81 78 10 4f 1c
	00 00		 cmp	 DWORD PTR [eax+16], 7247 ; 00001c4fH
  0003c	75 0b		 jne	 SHORT $LN5@gzeof
  0003e	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00041	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  00044	89 55 f8	 mov	 DWORD PTR tv72[ebp], edx
  00047	eb 07		 jmp	 SHORT $LN6@gzeof
$LN5@gzeof:
  00049	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv72[ebp], 0
$LN6@gzeof:
  00050	8b 45 f8	 mov	 eax, DWORD PTR tv72[ebp]
$LN3@gzeof:

; 515  : }

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
_gzeof@4 ENDP
_TEXT	ENDS
PUBLIC	_gzoffset64@4
; Function compile flags: /Odtp
;	COMDAT _gzoffset64@4
_TEXT	SEGMENT
_state$ = -12						; size = 4
_offset$ = -8						; size = 8
_file$ = 8						; size = 4
_gzoffset64@4 PROC					; COMDAT

; 470  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 471  :     z_off64_t offset;
; 472  :     gz_statep state;
; 473  : 
; 474  :     /* get internal structure and check integrity */
; 475  :     if (file == NULL)

  00006	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  0000a	75 08		 jne	 SHORT $LN4@gzoffset64

; 476  :         return -1;

  0000c	83 c8 ff	 or	 eax, -1
  0000f	83 ca ff	 or	 edx, -1
  00012	eb 7e		 jmp	 SHORT $LN5@gzoffset64
$LN4@gzoffset64:

; 477  :     state = (gz_statep)file;

  00014	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00017	89 45 f4	 mov	 DWORD PTR _state$[ebp], eax

; 478  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  0001a	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  0001d	81 79 10 4f 1c
	00 00		 cmp	 DWORD PTR [ecx+16], 7247 ; 00001c4fH
  00024	74 14		 je	 SHORT $LN3@gzoffset64
  00026	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  00029	81 7a 10 b1 79
	00 00		 cmp	 DWORD PTR [edx+16], 31153 ; 000079b1H
  00030	74 08		 je	 SHORT $LN3@gzoffset64

; 479  :         return -1;

  00032	83 c8 ff	 or	 eax, -1
  00035	83 ca ff	 or	 edx, -1
  00038	eb 58		 jmp	 SHORT $LN5@gzoffset64
$LN3@gzoffset64:

; 480  : 
; 481  :     /* compute and return effective offset in file */
; 482  :     offset = LSEEK(state->fd, 0, SEEK_CUR);

  0003a	6a 01		 push	 1
  0003c	6a 00		 push	 0
  0003e	6a 00		 push	 0
  00040	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  00043	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00046	51		 push	 ecx
  00047	e8 00 00 00 00	 call	 __lseeki64
  0004c	83 c4 10	 add	 esp, 16			; 00000010H
  0004f	89 45 f8	 mov	 DWORD PTR _offset$[ebp], eax
  00052	89 55 fc	 mov	 DWORD PTR _offset$[ebp+4], edx

; 483  :     if (offset == -1)

  00055	8b 55 f8	 mov	 edx, DWORD PTR _offset$[ebp]
  00058	23 55 fc	 and	 edx, DWORD PTR _offset$[ebp+4]
  0005b	83 fa ff	 cmp	 edx, -1
  0005e	75 08		 jne	 SHORT $LN2@gzoffset64

; 484  :         return -1;

  00060	83 c8 ff	 or	 eax, -1
  00063	83 ca ff	 or	 edx, -1
  00066	eb 2a		 jmp	 SHORT $LN5@gzoffset64
$LN2@gzoffset64:

; 485  :     if (state->mode == GZ_READ)             /* reading */

  00068	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  0006b	81 78 10 4f 1c
	00 00		 cmp	 DWORD PTR [eax+16], 7247 ; 00001c4fH
  00072	75 18		 jne	 SHORT $LN1@gzoffset64

; 486  :         offset -= state->strm.avail_in;     /* don't count buffered input */

  00074	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  00077	8b 51 68	 mov	 edx, DWORD PTR [ecx+104]
  0007a	33 c0		 xor	 eax, eax
  0007c	8b 4d f8	 mov	 ecx, DWORD PTR _offset$[ebp]
  0007f	2b ca		 sub	 ecx, edx
  00081	8b 55 fc	 mov	 edx, DWORD PTR _offset$[ebp+4]
  00084	1b d0		 sbb	 edx, eax
  00086	89 4d f8	 mov	 DWORD PTR _offset$[ebp], ecx
  00089	89 55 fc	 mov	 DWORD PTR _offset$[ebp+4], edx
$LN1@gzoffset64:

; 487  :     return offset;

  0008c	8b 45 f8	 mov	 eax, DWORD PTR _offset$[ebp]
  0008f	8b 55 fc	 mov	 edx, DWORD PTR _offset$[ebp+4]
$LN5@gzoffset64:

; 488  : }

  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c2 04 00	 ret	 4
_gzoffset64@4 ENDP
_TEXT	ENDS
PUBLIC	_gztell64@4
; Function compile flags: /Odtp
;	COMDAT _gztell64@4
_TEXT	SEGMENT
tv73 = -12						; size = 8
_state$ = -4						; size = 4
_file$ = 8						; size = 4
_gztell64@4 PROC					; COMDAT

; 443  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 444  :     gz_statep state;
; 445  : 
; 446  :     /* get internal structure and check integrity */
; 447  :     if (file == NULL)

  00006	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  0000a	75 08		 jne	 SHORT $LN2@gztell64

; 448  :         return -1;

  0000c	83 c8 ff	 or	 eax, -1
  0000f	83 ca ff	 or	 edx, -1
  00012	eb 5d		 jmp	 SHORT $LN3@gztell64
$LN2@gztell64:

; 449  :     state = (gz_statep)file;

  00014	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00017	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax

; 450  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0001d	81 79 10 4f 1c
	00 00		 cmp	 DWORD PTR [ecx+16], 7247 ; 00001c4fH
  00024	74 14		 je	 SHORT $LN1@gztell64
  00026	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00029	81 7a 10 b1 79
	00 00		 cmp	 DWORD PTR [edx+16], 31153 ; 000079b1H
  00030	74 08		 je	 SHORT $LN1@gztell64

; 451  :         return -1;

  00032	83 c8 ff	 or	 eax, -1
  00035	83 ca ff	 or	 edx, -1
  00038	eb 37		 jmp	 SHORT $LN3@gztell64
$LN1@gztell64:

; 452  : 
; 453  :     /* return position */
; 454  :     return state->x.pos + (state->seek ? state->skip : 0);

  0003a	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0003d	83 78 58 00	 cmp	 DWORD PTR [eax+88], 0
  00041	74 11		 je	 SHORT $LN5@gztell64
  00043	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00046	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  00049	89 55 f4	 mov	 DWORD PTR tv73[ebp], edx
  0004c	8b 41 54	 mov	 eax, DWORD PTR [ecx+84]
  0004f	89 45 f8	 mov	 DWORD PTR tv73[ebp+4], eax
  00052	eb 0e		 jmp	 SHORT $LN6@gztell64
$LN5@gztell64:
  00054	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  0005b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv73[ebp+4], 0
$LN6@gztell64:
  00062	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00065	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00068	03 45 f4	 add	 eax, DWORD PTR tv73[ebp]
  0006b	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0006e	13 55 f8	 adc	 edx, DWORD PTR tv73[ebp+4]
$LN3@gztell64:

; 455  : }

  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c2 04 00	 ret	 4
_gztell64@4 ENDP
_TEXT	ENDS
PUBLIC	_gzbuffer@8
; Function compile flags: /Odtp
;	COMDAT _gzbuffer@8
_TEXT	SEGMENT
_state$ = -4						; size = 4
_file$ = 8						; size = 4
_size$ = 12						; size = 4
_gzbuffer@8 PROC					; COMDAT

; 307  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 308  :     gz_statep state;
; 309  : 
; 310  :     /* get internal structure and check integrity */
; 311  :     if (file == NULL)

  00004	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  00008	75 05		 jne	 SHORT $LN4@gzbuffer

; 312  :         return -1;

  0000a	83 c8 ff	 or	 eax, -1
  0000d	eb 49		 jmp	 SHORT $LN5@gzbuffer
$LN4@gzbuffer:

; 313  :     state = (gz_statep)file;

  0000f	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax

; 314  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00018	81 79 10 4f 1c
	00 00		 cmp	 DWORD PTR [ecx+16], 7247 ; 00001c4fH
  0001f	74 11		 je	 SHORT $LN3@gzbuffer
  00021	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00024	81 7a 10 b1 79
	00 00		 cmp	 DWORD PTR [edx+16], 31153 ; 000079b1H
  0002b	74 05		 je	 SHORT $LN3@gzbuffer

; 315  :         return -1;

  0002d	83 c8 ff	 or	 eax, -1
  00030	eb 26		 jmp	 SHORT $LN5@gzbuffer
$LN3@gzbuffer:

; 316  : 
; 317  :     /* make sure we haven't already allocated memory */
; 318  :     if (state->size != 0)

  00032	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00035	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00039	74 05		 je	 SHORT $LN2@gzbuffer

; 319  :         return -1;

  0003b	83 c8 ff	 or	 eax, -1
  0003e	eb 18		 jmp	 SHORT $LN5@gzbuffer
$LN2@gzbuffer:

; 320  : 
; 321  :     /* check and set requested size */
; 322  :     if (size < 2)

  00040	83 7d 0c 02	 cmp	 DWORD PTR _size$[ebp], 2
  00044	73 07		 jae	 SHORT $LN1@gzbuffer

; 323  :         size = 2;               /* need two bytes to check magic header */

  00046	c7 45 0c 02 00
	00 00		 mov	 DWORD PTR _size$[ebp], 2
$LN1@gzbuffer:

; 324  :     state->want = size;

  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00050	8b 55 0c	 mov	 edx, DWORD PTR _size$[ebp]
  00053	89 51 20	 mov	 DWORD PTR [ecx+32], edx

; 325  :     return 0;

  00056	33 c0		 xor	 eax, eax
$LN5@gzbuffer:

; 326  : }

  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c2 08 00	 ret	 8
_gzbuffer@8 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _gz_reset
_TEXT	SEGMENT
_state$ = 8						; size = 4
_gz_reset PROC						; COMDAT

; 77   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 78   :     state->x.have = 0;              /* no output data available */

  00003	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00006	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 79   :     if (state->mode == GZ_READ) {   /* for reading ... */

  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0000f	81 79 10 4f 1c
	00 00		 cmp	 DWORD PTR [ecx+16], 7247 ; 00001c4fH
  00016	75 1e		 jne	 SHORT $LN1@gz_reset

; 80   :         state->eof = 0;             /* not at end of file */

  00018	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0001b	c7 42 40 00 00
	00 00		 mov	 DWORD PTR [edx+64], 0

; 81   :         state->past = 0;            /* have not read past end yet */

  00022	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00025	c7 40 44 00 00
	00 00		 mov	 DWORD PTR [eax+68], 0

; 82   :         state->how = LOOK;          /* look for gzip header */

  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0002f	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], 0
$LN1@gz_reset:

; 83   :     }
; 84   :     state->seek = 0;                /* no seek request pending */

  00036	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00039	c7 42 58 00 00
	00 00		 mov	 DWORD PTR [edx+88], 0

; 85   :     gz_error(state, Z_OK, NULL);    /* clear error */

  00040	6a 00		 push	 0
  00042	6a 00		 push	 0
  00044	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 _gz_error
  0004d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 86   :     state->x.pos = 0;               /* no uncompressed data yet */

  00050	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00053	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  0005a	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 87   :     state->strm.avail_in = 0;       /* no input data yet */

  00061	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00064	c7 42 68 00 00
	00 00		 mov	 DWORD PTR [edx+104], 0

; 88   : }

  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
_gz_reset ENDP
PUBLIC	_gzoffset@4
; Function compile flags: /Odtp
;	COMDAT _gzoffset@4
_TEXT	SEGMENT
tv70 = -20						; size = 4
tv83 = -16						; size = 8
_ret$ = -8						; size = 8
_file$ = 8						; size = 4
_gzoffset@4 PROC					; COMDAT

; 493  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 494  :     z_off64_t ret;
; 495  : 
; 496  :     ret = gzoffset64(file);

  00006	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _gzoffset64@4
  0000f	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax
  00012	89 55 fc	 mov	 DWORD PTR _ret$[ebp+4], edx

; 497  :     return ret == (z_off_t)ret ? (z_off_t)ret : -1;

  00015	8b 45 f8	 mov	 eax, DWORD PTR _ret$[ebp]
  00018	99		 cdq
  00019	89 45 f0	 mov	 DWORD PTR tv83[ebp], eax
  0001c	89 55 f4	 mov	 DWORD PTR tv83[ebp+4], edx
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR _ret$[ebp]
  00022	3b 4d f0	 cmp	 ecx, DWORD PTR tv83[ebp]
  00025	75 10		 jne	 SHORT $LN3@gzoffset
  00027	8b 55 fc	 mov	 edx, DWORD PTR _ret$[ebp+4]
  0002a	3b 55 f4	 cmp	 edx, DWORD PTR tv83[ebp+4]
  0002d	75 08		 jne	 SHORT $LN3@gzoffset
  0002f	8b 45 f8	 mov	 eax, DWORD PTR _ret$[ebp]
  00032	89 45 ec	 mov	 DWORD PTR tv70[ebp], eax
  00035	eb 07		 jmp	 SHORT $LN4@gzoffset
$LN3@gzoffset:
  00037	c7 45 ec ff ff
	ff ff		 mov	 DWORD PTR tv70[ebp], -1
$LN4@gzoffset:
  0003e	8b 45 ec	 mov	 eax, DWORD PTR tv70[ebp]

; 498  : }

  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
_gzoffset@4 ENDP
_TEXT	ENDS
PUBLIC	_gztell@4
; Function compile flags: /Odtp
;	COMDAT _gztell@4
_TEXT	SEGMENT
tv70 = -20						; size = 4
tv83 = -16						; size = 8
_ret$ = -8						; size = 8
_file$ = 8						; size = 4
_gztell@4 PROC						; COMDAT

; 460  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 461  :     z_off64_t ret;
; 462  : 
; 463  :     ret = gztell64(file);

  00006	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _gztell64@4
  0000f	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax
  00012	89 55 fc	 mov	 DWORD PTR _ret$[ebp+4], edx

; 464  :     return ret == (z_off_t)ret ? (z_off_t)ret : -1;

  00015	8b 45 f8	 mov	 eax, DWORD PTR _ret$[ebp]
  00018	99		 cdq
  00019	89 45 f0	 mov	 DWORD PTR tv83[ebp], eax
  0001c	89 55 f4	 mov	 DWORD PTR tv83[ebp+4], edx
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR _ret$[ebp]
  00022	3b 4d f0	 cmp	 ecx, DWORD PTR tv83[ebp]
  00025	75 10		 jne	 SHORT $LN3@gztell
  00027	8b 55 fc	 mov	 edx, DWORD PTR _ret$[ebp+4]
  0002a	3b 55 f4	 cmp	 edx, DWORD PTR tv83[ebp+4]
  0002d	75 08		 jne	 SHORT $LN3@gztell
  0002f	8b 45 f8	 mov	 eax, DWORD PTR _ret$[ebp]
  00032	89 45 ec	 mov	 DWORD PTR tv70[ebp], eax
  00035	eb 07		 jmp	 SHORT $LN4@gztell
$LN3@gztell:
  00037	c7 45 ec ff ff
	ff ff		 mov	 DWORD PTR tv70[ebp], -1
$LN4@gztell:
  0003e	8b 45 ec	 mov	 eax, DWORD PTR tv70[ebp]

; 465  : }

  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
_gztell@4 ENDP
_TEXT	ENDS
PUBLIC	_gzrewind@4
; Function compile flags: /Odtp
;	COMDAT _gzrewind@4
_TEXT	SEGMENT
tv130 = -12						; size = 8
_state$ = -4						; size = 4
_file$ = 8						; size = 4
_gzrewind@4 PROC					; COMDAT

; 331  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 332  :     gz_statep state;
; 333  : 
; 334  :     /* get internal structure */
; 335  :     if (file == NULL)

  00006	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  0000a	75 05		 jne	 SHORT $LN4@gzrewind

; 336  :         return -1;

  0000c	83 c8 ff	 or	 eax, -1
  0000f	eb 69		 jmp	 SHORT $LN5@gzrewind
$LN4@gzrewind:

; 337  :     state = (gz_statep)file;

  00011	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00014	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax

; 338  : 
; 339  :     /* check that we're reading and that there's no error */
; 340  :     if (state->mode != GZ_READ ||
; 341  :             (state->err != Z_OK && state->err != Z_BUF_ERROR))

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0001a	81 79 10 4f 1c
	00 00		 cmp	 DWORD PTR [ecx+16], 7247 ; 00001c4fH
  00021	75 12		 jne	 SHORT $LN2@gzrewind
  00023	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00026	83 7a 5c 00	 cmp	 DWORD PTR [edx+92], 0
  0002a	74 0e		 je	 SHORT $LN3@gzrewind
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0002f	83 78 5c fb	 cmp	 DWORD PTR [eax+92], -5	; fffffffbH
  00033	74 05		 je	 SHORT $LN3@gzrewind
$LN2@gzrewind:

; 342  :         return -1;

  00035	83 c8 ff	 or	 eax, -1
  00038	eb 40		 jmp	 SHORT $LN5@gzrewind
$LN3@gzrewind:

; 343  : 
; 344  :     /* back up and start over */
; 345  :     if (LSEEK(state->fd, state->start, SEEK_SET) == -1)

  0003a	6a 00		 push	 0
  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0003f	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  00042	52		 push	 edx
  00043	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]
  00046	50		 push	 eax
  00047	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0004a	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0004d	52		 push	 edx
  0004e	e8 00 00 00 00	 call	 __lseeki64
  00053	83 c4 10	 add	 esp, 16			; 00000010H
  00056	89 45 f4	 mov	 DWORD PTR tv130[ebp], eax
  00059	89 55 f8	 mov	 DWORD PTR tv130[ebp+4], edx
  0005c	8b 45 f4	 mov	 eax, DWORD PTR tv130[ebp]
  0005f	23 45 f8	 and	 eax, DWORD PTR tv130[ebp+4]
  00062	83 f8 ff	 cmp	 eax, -1
  00065	75 05		 jne	 SHORT $LN1@gzrewind

; 346  :         return -1;

  00067	83 c8 ff	 or	 eax, -1
  0006a	eb 0e		 jmp	 SHORT $LN5@gzrewind
$LN1@gzrewind:

; 347  :     gz_reset(state);

  0006c	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0006f	51		 push	 ecx
  00070	e8 00 00 00 00	 call	 _gz_reset
  00075	83 c4 04	 add	 esp, 4

; 348  :     return 0;

  00078	33 c0		 xor	 eax, eax
$LN5@gzrewind:

; 349  : }

  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c2 04 00	 ret	 4
_gzrewind@4 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _gz_open
_TEXT	SEGMENT
tv307 = -36						; size = 4
tv188 = -32						; size = 4
tv189 = -28						; size = 4
tv175 = -24						; size = 4
tv85 = -20						; size = 4
_state$ = -16						; size = 4
_oflag$ = -12						; size = 4
_len$ = -8						; size = 4
_exclusive$ = -4					; size = 4
_path$ = 8						; size = 4
_fd$ = 12						; size = 4
_mode$ = 16						; size = 4
_gz_open PROC						; COMDAT

; 95   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H

; 96   :     gz_statep state;
; 97   :     size_t len;
; 98   :     int oflag;
; 99   : #ifdef O_CLOEXEC
; 100  :     int cloexec = 0;
; 101  : #endif
; 102  : #ifdef O_EXCL
; 103  :     int exclusive = 0;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _exclusive$[ebp], 0

; 104  : #endif
; 105  : 
; 106  :     /* check input */
; 107  :     if (path == NULL)

  0000d	83 7d 08 00	 cmp	 DWORD PTR _path$[ebp], 0
  00011	75 07		 jne	 SHORT $LN35@gz_open

; 108  :         return NULL;

  00013	33 c0		 xor	 eax, eax
  00015	e9 92 03 00 00	 jmp	 $LN36@gz_open
$LN35@gz_open:

; 109  : 
; 110  :     /* allocate gzFile structure to return */
; 111  :     state = malloc(sizeof(gz_state));

  0001a	68 a0 00 00 00	 push	 160			; 000000a0H
  0001f	e8 00 00 00 00	 call	 _malloc
  00024	83 c4 04	 add	 esp, 4
  00027	89 45 f0	 mov	 DWORD PTR _state$[ebp], eax

; 112  :     if (state == NULL)

  0002a	83 7d f0 00	 cmp	 DWORD PTR _state$[ebp], 0
  0002e	75 07		 jne	 SHORT $LN34@gz_open

; 113  :         return NULL;

  00030	33 c0		 xor	 eax, eax
  00032	e9 75 03 00 00	 jmp	 $LN36@gz_open
$LN34@gz_open:

; 114  :     state->size = 0;            /* no buffers allocated yet */

  00037	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  0003a	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 115  :     state->want = GZBUFSIZE;    /* requested buffer size */

  00041	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00044	c7 41 20 00 20
	00 00		 mov	 DWORD PTR [ecx+32], 8192 ; 00002000H

; 116  :     state->msg = NULL;          /* no error message yet */

  0004b	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  0004e	c7 42 60 00 00
	00 00		 mov	 DWORD PTR [edx+96], 0

; 117  : 
; 118  :     /* interpret mode */
; 119  :     state->mode = GZ_NONE;

  00055	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00058	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 120  :     state->level = Z_DEFAULT_COMPRESSION;

  0005f	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00062	c7 41 48 ff ff
	ff ff		 mov	 DWORD PTR [ecx+72], -1

; 121  :     state->strategy = Z_DEFAULT_STRATEGY;

  00069	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  0006c	c7 42 4c 00 00
	00 00		 mov	 DWORD PTR [edx+76], 0

; 122  :     state->direct = 0;

  00073	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00076	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], 0
$LN33@gz_open:

; 123  :     while (*mode) {

  0007d	8b 4d 10	 mov	 ecx, DWORD PTR _mode$[ebp]
  00080	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00083	85 d2		 test	 edx, edx
  00085	0f 84 df 00 00
	00		 je	 $LN32@gz_open

; 124  :         if (*mode >= '0' && *mode <= '9')

  0008b	8b 45 10	 mov	 eax, DWORD PTR _mode$[ebp]
  0008e	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00091	83 f9 30	 cmp	 ecx, 48			; 00000030H
  00094	7c 1f		 jl	 SHORT $LN31@gz_open
  00096	8b 55 10	 mov	 edx, DWORD PTR _mode$[ebp]
  00099	0f be 02	 movsx	 eax, BYTE PTR [edx]
  0009c	83 f8 39	 cmp	 eax, 57			; 00000039H
  0009f	7f 14		 jg	 SHORT $LN31@gz_open

; 125  :             state->level = *mode - '0';

  000a1	8b 4d 10	 mov	 ecx, DWORD PTR _mode$[ebp]
  000a4	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  000a7	83 ea 30	 sub	 edx, 48			; 00000030H
  000aa	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  000ad	89 50 48	 mov	 DWORD PTR [eax+72], edx

; 126  :         else

  000b0	e9 a7 00 00 00	 jmp	 $LN30@gz_open
$LN31@gz_open:

; 127  :             switch (*mode) {

  000b5	8b 4d 10	 mov	 ecx, DWORD PTR _mode$[ebp]
  000b8	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  000bb	89 55 ec	 mov	 DWORD PTR tv85[ebp], edx
  000be	8b 45 ec	 mov	 eax, DWORD PTR tv85[ebp]
  000c1	83 e8 2b	 sub	 eax, 43			; 0000002bH
  000c4	89 45 ec	 mov	 DWORD PTR tv85[ebp], eax
  000c7	83 7d ec 4d	 cmp	 DWORD PTR tv85[ebp], 77	; 0000004dH
  000cb	0f 87 8b 00 00
	00		 ja	 $LN30@gz_open
  000d1	8b 4d ec	 mov	 ecx, DWORD PTR tv85[ebp]
  000d4	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR $LN44@gz_open[ecx]
  000db	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN45@gz_open[edx*4]
$LN27@gz_open:

; 128  :             case 'r':
; 129  :                 state->mode = GZ_READ;

  000e2	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  000e5	c7 40 10 4f 1c
	00 00		 mov	 DWORD PTR [eax+16], 7247 ; 00001c4fH

; 130  :                 break;

  000ec	eb 6e		 jmp	 SHORT $LN30@gz_open
$LN26@gz_open:

; 131  : #ifndef NO_GZCOMPRESS
; 132  :             case 'w':
; 133  :                 state->mode = GZ_WRITE;

  000ee	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  000f1	c7 41 10 b1 79
	00 00		 mov	 DWORD PTR [ecx+16], 31153 ; 000079b1H

; 134  :                 break;

  000f8	eb 62		 jmp	 SHORT $LN30@gz_open
$LN25@gz_open:

; 135  :             case 'a':
; 136  :                 state->mode = GZ_APPEND;

  000fa	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  000fd	c7 42 10 01 00
	00 00		 mov	 DWORD PTR [edx+16], 1

; 137  :                 break;

  00104	eb 56		 jmp	 SHORT $LN30@gz_open
$LN24@gz_open:

; 138  : #endif
; 139  :             case '+':       /* can't read and write at the same time */
; 140  :                 free(state);

  00106	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00109	50		 push	 eax
  0010a	e8 00 00 00 00	 call	 _free
  0010f	83 c4 04	 add	 esp, 4

; 141  :                 return NULL;

  00112	33 c0		 xor	 eax, eax
  00114	e9 93 02 00 00	 jmp	 $LN36@gz_open

; 142  :             case 'b':       /* ignore -- will request binary anyway */
; 143  :                 break;

  00119	eb 41		 jmp	 SHORT $LN30@gz_open
$LN22@gz_open:

; 144  : #ifdef O_CLOEXEC
; 145  :             case 'e':
; 146  :                 cloexec = 1;
; 147  :                 break;
; 148  : #endif
; 149  : #ifdef O_EXCL
; 150  :             case 'x':
; 151  :                 exclusive = 1;

  0011b	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _exclusive$[ebp], 1

; 152  :                 break;

  00122	eb 38		 jmp	 SHORT $LN30@gz_open
$LN21@gz_open:

; 153  : #endif
; 154  :             case 'f':
; 155  :                 state->strategy = Z_FILTERED;

  00124	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00127	c7 41 4c 01 00
	00 00		 mov	 DWORD PTR [ecx+76], 1

; 156  :                 break;

  0012e	eb 2c		 jmp	 SHORT $LN30@gz_open
$LN20@gz_open:

; 157  :             case 'h':
; 158  :                 state->strategy = Z_HUFFMAN_ONLY;

  00130	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00133	c7 42 4c 02 00
	00 00		 mov	 DWORD PTR [edx+76], 2

; 159  :                 break;

  0013a	eb 20		 jmp	 SHORT $LN30@gz_open
$LN19@gz_open:

; 160  :             case 'R':
; 161  :                 state->strategy = Z_RLE;

  0013c	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  0013f	c7 40 4c 03 00
	00 00		 mov	 DWORD PTR [eax+76], 3

; 162  :                 break;

  00146	eb 14		 jmp	 SHORT $LN30@gz_open
$LN18@gz_open:

; 163  :             case 'F':
; 164  :                 state->strategy = Z_FIXED;

  00148	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  0014b	c7 41 4c 04 00
	00 00		 mov	 DWORD PTR [ecx+76], 4
$LN17@gz_open:

; 165  :             case 'T':
; 166  :                 state->direct = 1;

  00152	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00155	c7 42 2c 01 00
	00 00		 mov	 DWORD PTR [edx+44], 1
$LN30@gz_open:

; 167  :             default:        /* could consider as an error, but just ignore */
; 168  :                 ;
; 169  :             }
; 170  :         mode++;

  0015c	8b 45 10	 mov	 eax, DWORD PTR _mode$[ebp]
  0015f	83 c0 01	 add	 eax, 1
  00162	89 45 10	 mov	 DWORD PTR _mode$[ebp], eax

; 171  :     }

  00165	e9 13 ff ff ff	 jmp	 $LN33@gz_open
$LN32@gz_open:

; 172  : 
; 173  :     /* must provide an "r", "w", or "a" */
; 174  :     if (state->mode == GZ_NONE) {

  0016a	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  0016d	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  00171	75 13		 jne	 SHORT $LN15@gz_open

; 175  :         free(state);

  00173	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00176	52		 push	 edx
  00177	e8 00 00 00 00	 call	 _free
  0017c	83 c4 04	 add	 esp, 4

; 176  :         return NULL;

  0017f	33 c0		 xor	 eax, eax
  00181	e9 26 02 00 00	 jmp	 $LN36@gz_open
$LN15@gz_open:

; 177  :     }
; 178  : 
; 179  :     /* can't force transparent read */
; 180  :     if (state->mode == GZ_READ) {

  00186	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00189	81 78 10 4f 1c
	00 00		 cmp	 DWORD PTR [eax+16], 7247 ; 00001c4fH
  00190	75 26		 jne	 SHORT $LN14@gz_open

; 181  :         if (state->direct) {

  00192	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00195	83 79 2c 00	 cmp	 DWORD PTR [ecx+44], 0
  00199	74 13		 je	 SHORT $LN13@gz_open

; 182  :             free(state);

  0019b	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  0019e	52		 push	 edx
  0019f	e8 00 00 00 00	 call	 _free
  001a4	83 c4 04	 add	 esp, 4

; 183  :             return NULL;

  001a7	33 c0		 xor	 eax, eax
  001a9	e9 fe 01 00 00	 jmp	 $LN36@gz_open
$LN13@gz_open:

; 184  :         }
; 185  :         state->direct = 1;      /* for empty file */

  001ae	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  001b1	c7 40 2c 01 00
	00 00		 mov	 DWORD PTR [eax+44], 1
$LN14@gz_open:

; 186  :     }
; 187  : 
; 188  :     /* save the path name for error messages */
; 189  : #ifdef _WIN32
; 190  :     if (fd == -2) {

  001b8	83 7d 0c fe	 cmp	 DWORD PTR _fd$[ebp], -2	; fffffffeH
  001bc	75 22		 jne	 SHORT $LN12@gz_open

; 191  :         len = wcstombs(NULL, path, 0);

  001be	6a 00		 push	 0
  001c0	8b 4d 08	 mov	 ecx, DWORD PTR _path$[ebp]
  001c3	51		 push	 ecx
  001c4	6a 00		 push	 0
  001c6	e8 00 00 00 00	 call	 _wcstombs
  001cb	83 c4 0c	 add	 esp, 12			; 0000000cH
  001ce	89 45 f8	 mov	 DWORD PTR _len$[ebp], eax

; 192  :         if (len == (size_t)-1)

  001d1	83 7d f8 ff	 cmp	 DWORD PTR _len$[ebp], -1
  001d5	75 07		 jne	 SHORT $LN11@gz_open

; 193  :             len = 0;

  001d7	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _len$[ebp], 0
$LN11@gz_open:

; 194  :     }
; 195  :     else

  001de	eb 0f		 jmp	 SHORT $LN10@gz_open
$LN12@gz_open:

; 196  : #endif
; 197  :         len = strlen(path);

  001e0	8b 55 08	 mov	 edx, DWORD PTR _path$[ebp]
  001e3	52		 push	 edx
  001e4	e8 00 00 00 00	 call	 _strlen
  001e9	83 c4 04	 add	 esp, 4
  001ec	89 45 f8	 mov	 DWORD PTR _len$[ebp], eax
$LN10@gz_open:

; 198  :     state->path = malloc(len + 1);

  001ef	8b 45 f8	 mov	 eax, DWORD PTR _len$[ebp]
  001f2	83 c0 01	 add	 eax, 1
  001f5	50		 push	 eax
  001f6	e8 00 00 00 00	 call	 _malloc
  001fb	83 c4 04	 add	 esp, 4
  001fe	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00201	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 199  :     if (state->path == NULL) {

  00204	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00207	83 7a 18 00	 cmp	 DWORD PTR [edx+24], 0
  0020b	75 13		 jne	 SHORT $LN9@gz_open

; 200  :         free(state);

  0020d	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00210	50		 push	 eax
  00211	e8 00 00 00 00	 call	 _free
  00216	83 c4 04	 add	 esp, 4

; 201  :         return NULL;

  00219	33 c0		 xor	 eax, eax
  0021b	e9 8c 01 00 00	 jmp	 $LN36@gz_open
$LN9@gz_open:

; 202  :     }
; 203  : #ifdef _WIN32
; 204  :     if (fd == -2)

  00220	83 7d 0c fe	 cmp	 DWORD PTR _fd$[ebp], -2	; fffffffeH
  00224	75 2d		 jne	 SHORT $LN8@gz_open

; 205  :         if (len)

  00226	83 7d f8 00	 cmp	 DWORD PTR _len$[ebp], 0
  0022a	74 1c		 je	 SHORT $LN7@gz_open

; 206  :             wcstombs(state->path, path, len + 1);

  0022c	8b 4d f8	 mov	 ecx, DWORD PTR _len$[ebp]
  0022f	83 c1 01	 add	 ecx, 1
  00232	51		 push	 ecx
  00233	8b 55 08	 mov	 edx, DWORD PTR _path$[ebp]
  00236	52		 push	 edx
  00237	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  0023a	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0023d	51		 push	 ecx
  0023e	e8 00 00 00 00	 call	 _wcstombs
  00243	83 c4 0c	 add	 esp, 12			; 0000000cH

; 207  :         else

  00246	eb 09		 jmp	 SHORT $LN6@gz_open
$LN7@gz_open:

; 208  :             *(state->path) = 0;

  00248	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  0024b	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0024e	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN6@gz_open:

; 209  :     else

  00251	eb 13		 jmp	 SHORT $LN5@gz_open
$LN8@gz_open:

; 210  : #endif
; 211  :         strcpy(state->path, path);

  00253	8b 4d 08	 mov	 ecx, DWORD PTR _path$[ebp]
  00256	51		 push	 ecx
  00257	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  0025a	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0025d	50		 push	 eax
  0025e	e8 00 00 00 00	 call	 _strcpy
  00263	83 c4 08	 add	 esp, 8
$LN5@gz_open:

; 212  : 
; 213  :     /* compute the flags for open() */
; 214  :     oflag =
; 215  : #ifdef O_LARGEFILE
; 216  :         O_LARGEFILE |
; 217  : #endif
; 218  : #ifdef O_BINARY
; 219  :         O_BINARY |
; 220  : #endif
; 221  : #ifdef O_CLOEXEC
; 222  :         (cloexec ? O_CLOEXEC : 0) |
; 223  : #endif
; 224  :         (state->mode == GZ_READ ?
; 225  :          O_RDONLY :
; 226  :          (O_WRONLY | O_CREAT |
; 227  : #ifdef O_EXCL
; 228  :           (exclusive ? O_EXCL : 0) |
; 229  : #endif
; 230  :           (state->mode == GZ_WRITE ?
; 231  :            O_TRUNC :
; 232  :            O_APPEND)));

  00266	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00269	81 79 10 4f 1c
	00 00		 cmp	 DWORD PTR [ecx+16], 7247 ; 00001c4fH
  00270	75 09		 jne	 SHORT $LN38@gz_open
  00272	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv175[ebp], 0
  00279	eb 34		 jmp	 SHORT $LN39@gz_open
$LN38@gz_open:
  0027b	8b 55 fc	 mov	 edx, DWORD PTR _exclusive$[ebp]
  0027e	f7 da		 neg	 edx
  00280	1b d2		 sbb	 edx, edx
  00282	81 e2 00 04 00
	00		 and	 edx, 1024		; 00000400H
  00288	81 ca 01 01 00
	00		 or	 edx, 257		; 00000101H
  0028e	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00291	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00294	81 e9 b1 79 00
	00		 sub	 ecx, 31153		; 000079b1H
  0029a	f7 d9		 neg	 ecx
  0029c	1b c9		 sbb	 ecx, ecx
  0029e	81 e1 08 fe ff
	ff		 and	 ecx, -504		; fffffe08H
  002a4	81 c1 00 02 00
	00		 add	 ecx, 512		; 00000200H
  002aa	0b d1		 or	 edx, ecx
  002ac	89 55 e8	 mov	 DWORD PTR tv175[ebp], edx
$LN39@gz_open:
  002af	8b 55 e8	 mov	 edx, DWORD PTR tv175[ebp]
  002b2	81 ca 00 80 00
	00		 or	 edx, 32768		; 00008000H
  002b8	89 55 f4	 mov	 DWORD PTR _oflag$[ebp], edx

; 233  : 
; 234  :     /* open the file with the appropriate flags (or just use fd) */
; 235  :     state->fd = fd > -1 ? fd : (
; 236  : #ifdef _WIN32
; 237  :         fd == -2 ? _wopen(path, oflag, 0666) :
; 238  : #endif
; 239  :         open(path, oflag, 0666));

  002bb	83 7d 0c ff	 cmp	 DWORD PTR _fd$[ebp], -1
  002bf	7e 08		 jle	 SHORT $LN42@gz_open
  002c1	8b 45 0c	 mov	 eax, DWORD PTR _fd$[ebp]
  002c4	89 45 e4	 mov	 DWORD PTR tv189[ebp], eax
  002c7	eb 3e		 jmp	 SHORT $LN43@gz_open
$LN42@gz_open:
  002c9	83 7d 0c fe	 cmp	 DWORD PTR _fd$[ebp], -2	; fffffffeH
  002cd	75 1a		 jne	 SHORT $LN40@gz_open
  002cf	68 b6 01 00 00	 push	 438			; 000001b6H
  002d4	8b 4d f4	 mov	 ecx, DWORD PTR _oflag$[ebp]
  002d7	51		 push	 ecx
  002d8	8b 55 08	 mov	 edx, DWORD PTR _path$[ebp]
  002db	52		 push	 edx
  002dc	e8 00 00 00 00	 call	 __wopen
  002e1	83 c4 0c	 add	 esp, 12			; 0000000cH
  002e4	89 45 e0	 mov	 DWORD PTR tv188[ebp], eax
  002e7	eb 18		 jmp	 SHORT $LN41@gz_open
$LN40@gz_open:
  002e9	68 b6 01 00 00	 push	 438			; 000001b6H
  002ee	8b 45 f4	 mov	 eax, DWORD PTR _oflag$[ebp]
  002f1	50		 push	 eax
  002f2	8b 4d 08	 mov	 ecx, DWORD PTR _path$[ebp]
  002f5	51		 push	 ecx
  002f6	e8 00 00 00 00	 call	 _open
  002fb	83 c4 0c	 add	 esp, 12			; 0000000cH
  002fe	89 45 e0	 mov	 DWORD PTR tv188[ebp], eax
$LN41@gz_open:
  00301	8b 55 e0	 mov	 edx, DWORD PTR tv188[ebp]
  00304	89 55 e4	 mov	 DWORD PTR tv189[ebp], edx
$LN43@gz_open:
  00307	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  0030a	8b 4d e4	 mov	 ecx, DWORD PTR tv189[ebp]
  0030d	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 240  :     if (state->fd == -1) {

  00310	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00313	83 7a 14 ff	 cmp	 DWORD PTR [edx+20], -1
  00317	75 1f		 jne	 SHORT $LN4@gz_open

; 241  :         free(state->path);

  00319	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  0031c	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0031f	51		 push	 ecx
  00320	e8 00 00 00 00	 call	 _free
  00325	83 c4 04	 add	 esp, 4

; 242  :         free(state);

  00328	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  0032b	52		 push	 edx
  0032c	e8 00 00 00 00	 call	 _free
  00331	83 c4 04	 add	 esp, 4

; 243  :         return NULL;

  00334	33 c0		 xor	 eax, eax
  00336	eb 74		 jmp	 SHORT $LN36@gz_open
$LN4@gz_open:

; 244  :     }
; 245  :     if (state->mode == GZ_APPEND)

  00338	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  0033b	83 78 10 01	 cmp	 DWORD PTR [eax+16], 1
  0033f	75 0a		 jne	 SHORT $LN3@gz_open

; 246  :         state->mode = GZ_WRITE;         /* simplify later checks */

  00341	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00344	c7 41 10 b1 79
	00 00		 mov	 DWORD PTR [ecx+16], 31153 ; 000079b1H
$LN3@gz_open:

; 247  : 
; 248  :     /* save the current position for rewinding (only if reading) */
; 249  :     if (state->mode == GZ_READ) {

  0034b	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  0034e	81 7a 10 4f 1c
	00 00		 cmp	 DWORD PTR [edx+16], 7247 ; 00001c4fH
  00355	75 46		 jne	 SHORT $LN2@gz_open

; 250  :         state->start = LSEEK(state->fd, 0, SEEK_CUR);

  00357	6a 01		 push	 1
  00359	6a 00		 push	 0
  0035b	6a 00		 push	 0
  0035d	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00360	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00363	51		 push	 ecx
  00364	e8 00 00 00 00	 call	 __lseeki64
  00369	83 c4 10	 add	 esp, 16			; 00000010H
  0036c	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  0036f	89 41 38	 mov	 DWORD PTR [ecx+56], eax
  00372	89 51 3c	 mov	 DWORD PTR [ecx+60], edx

; 251  :         if (state->start == -1) state->start = 0;

  00375	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00378	89 55 dc	 mov	 DWORD PTR tv307[ebp], edx
  0037b	8b 45 dc	 mov	 eax, DWORD PTR tv307[ebp]
  0037e	8b 4d dc	 mov	 ecx, DWORD PTR tv307[ebp]
  00381	8b 50 38	 mov	 edx, DWORD PTR [eax+56]
  00384	23 51 3c	 and	 edx, DWORD PTR [ecx+60]
  00387	83 fa ff	 cmp	 edx, -1
  0038a	75 11		 jne	 SHORT $LN2@gz_open
  0038c	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  0038f	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [eax+56], 0
  00396	c7 40 3c 00 00
	00 00		 mov	 DWORD PTR [eax+60], 0
$LN2@gz_open:

; 252  :     }
; 253  : 
; 254  :     /* initialize stream */
; 255  :     gz_reset(state);

  0039d	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  003a0	51		 push	 ecx
  003a1	e8 00 00 00 00	 call	 _gz_reset
  003a6	83 c4 04	 add	 esp, 4

; 256  : 
; 257  :     /* return stream */
; 258  :     return (gzFile)state;

  003a9	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
$LN36@gz_open:

; 259  : }

  003ac	8b e5		 mov	 esp, ebp
  003ae	5d		 pop	 ebp
  003af	c3		 ret	 0
$LN45@gz_open:
  003b0	00 00 00 00	 DD	 $LN24@gz_open
  003b4	00 00 00 00	 DD	 $LN18@gz_open
  003b8	00 00 00 00	 DD	 $LN19@gz_open
  003bc	00 00 00 00	 DD	 $LN17@gz_open
  003c0	00 00 00 00	 DD	 $LN25@gz_open
  003c4	00 00 00 00	 DD	 $LN21@gz_open
  003c8	00 00 00 00	 DD	 $LN20@gz_open
  003cc	00 00 00 00	 DD	 $LN27@gz_open
  003d0	00 00 00 00	 DD	 $LN26@gz_open
  003d4	00 00 00 00	 DD	 $LN22@gz_open
  003d8	00 00 00 00	 DD	 $LN30@gz_open
$LN44@gz_open:
  003dc	00		 DB	 0
  003dd	0a		 DB	 10			; 0000000aH
  003de	0a		 DB	 10			; 0000000aH
  003df	0a		 DB	 10			; 0000000aH
  003e0	0a		 DB	 10			; 0000000aH
  003e1	0a		 DB	 10			; 0000000aH
  003e2	0a		 DB	 10			; 0000000aH
  003e3	0a		 DB	 10			; 0000000aH
  003e4	0a		 DB	 10			; 0000000aH
  003e5	0a		 DB	 10			; 0000000aH
  003e6	0a		 DB	 10			; 0000000aH
  003e7	0a		 DB	 10			; 0000000aH
  003e8	0a		 DB	 10			; 0000000aH
  003e9	0a		 DB	 10			; 0000000aH
  003ea	0a		 DB	 10			; 0000000aH
  003eb	0a		 DB	 10			; 0000000aH
  003ec	0a		 DB	 10			; 0000000aH
  003ed	0a		 DB	 10			; 0000000aH
  003ee	0a		 DB	 10			; 0000000aH
  003ef	0a		 DB	 10			; 0000000aH
  003f0	0a		 DB	 10			; 0000000aH
  003f1	0a		 DB	 10			; 0000000aH
  003f2	0a		 DB	 10			; 0000000aH
  003f3	0a		 DB	 10			; 0000000aH
  003f4	0a		 DB	 10			; 0000000aH
  003f5	0a		 DB	 10			; 0000000aH
  003f6	0a		 DB	 10			; 0000000aH
  003f7	01		 DB	 1
  003f8	0a		 DB	 10			; 0000000aH
  003f9	0a		 DB	 10			; 0000000aH
  003fa	0a		 DB	 10			; 0000000aH
  003fb	0a		 DB	 10			; 0000000aH
  003fc	0a		 DB	 10			; 0000000aH
  003fd	0a		 DB	 10			; 0000000aH
  003fe	0a		 DB	 10			; 0000000aH
  003ff	0a		 DB	 10			; 0000000aH
  00400	0a		 DB	 10			; 0000000aH
  00401	0a		 DB	 10			; 0000000aH
  00402	0a		 DB	 10			; 0000000aH
  00403	02		 DB	 2
  00404	0a		 DB	 10			; 0000000aH
  00405	03		 DB	 3
  00406	0a		 DB	 10			; 0000000aH
  00407	0a		 DB	 10			; 0000000aH
  00408	0a		 DB	 10			; 0000000aH
  00409	0a		 DB	 10			; 0000000aH
  0040a	0a		 DB	 10			; 0000000aH
  0040b	0a		 DB	 10			; 0000000aH
  0040c	0a		 DB	 10			; 0000000aH
  0040d	0a		 DB	 10			; 0000000aH
  0040e	0a		 DB	 10			; 0000000aH
  0040f	0a		 DB	 10			; 0000000aH
  00410	0a		 DB	 10			; 0000000aH
  00411	0a		 DB	 10			; 0000000aH
  00412	04		 DB	 4
  00413	0a		 DB	 10			; 0000000aH
  00414	0a		 DB	 10			; 0000000aH
  00415	0a		 DB	 10			; 0000000aH
  00416	0a		 DB	 10			; 0000000aH
  00417	05		 DB	 5
  00418	0a		 DB	 10			; 0000000aH
  00419	06		 DB	 6
  0041a	0a		 DB	 10			; 0000000aH
  0041b	0a		 DB	 10			; 0000000aH
  0041c	0a		 DB	 10			; 0000000aH
  0041d	0a		 DB	 10			; 0000000aH
  0041e	0a		 DB	 10			; 0000000aH
  0041f	0a		 DB	 10			; 0000000aH
  00420	0a		 DB	 10			; 0000000aH
  00421	0a		 DB	 10			; 0000000aH
  00422	0a		 DB	 10			; 0000000aH
  00423	07		 DB	 7
  00424	0a		 DB	 10			; 0000000aH
  00425	0a		 DB	 10			; 0000000aH
  00426	0a		 DB	 10			; 0000000aH
  00427	0a		 DB	 10			; 0000000aH
  00428	08		 DB	 8
  00429	09		 DB	 9
_gz_open ENDP
PUBLIC	_gzseek64@16
; Function compile flags: /Odtp
;	COMDAT _gzseek64@16
_TEXT	SEGMENT
tv156 = -40						; size = 4
tv282 = -36						; size = 8
tv211 = -28						; size = 8
_state$ = -20						; size = 4
_ret$ = -16						; size = 8
_n$ = -4						; size = 4
_file$ = 8						; size = 4
_offset$ = 12						; size = 8
_whence$ = 20						; size = 4
_gzseek64@16 PROC					; COMDAT

; 356  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H

; 357  :     unsigned n;
; 358  :     z_off64_t ret;
; 359  :     gz_statep state;
; 360  : 
; 361  :     /* get internal structure and check integrity */
; 362  :     if (file == NULL)

  00006	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  0000a	75 0b		 jne	 SHORT $LN15@gzseek64

; 363  :         return -1;

  0000c	83 c8 ff	 or	 eax, -1
  0000f	83 ca ff	 or	 edx, -1
  00012	e9 bc 02 00 00	 jmp	 $LN16@gzseek64
$LN15@gzseek64:

; 364  :     state = (gz_statep)file;

  00017	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  0001a	89 45 ec	 mov	 DWORD PTR _state$[ebp], eax

; 365  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  0001d	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  00020	81 79 10 4f 1c
	00 00		 cmp	 DWORD PTR [ecx+16], 7247 ; 00001c4fH
  00027	74 17		 je	 SHORT $LN14@gzseek64
  00029	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  0002c	81 7a 10 b1 79
	00 00		 cmp	 DWORD PTR [edx+16], 31153 ; 000079b1H
  00033	74 0b		 je	 SHORT $LN14@gzseek64

; 366  :         return -1;

  00035	83 c8 ff	 or	 eax, -1
  00038	83 ca ff	 or	 edx, -1
  0003b	e9 93 02 00 00	 jmp	 $LN16@gzseek64
$LN14@gzseek64:

; 367  : 
; 368  :     /* check that there's no error */
; 369  :     if (state->err != Z_OK && state->err != Z_BUF_ERROR)

  00040	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  00043	83 78 5c 00	 cmp	 DWORD PTR [eax+92], 0
  00047	74 14		 je	 SHORT $LN13@gzseek64
  00049	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  0004c	83 79 5c fb	 cmp	 DWORD PTR [ecx+92], -5	; fffffffbH
  00050	74 0b		 je	 SHORT $LN13@gzseek64

; 370  :         return -1;

  00052	83 c8 ff	 or	 eax, -1
  00055	83 ca ff	 or	 edx, -1
  00058	e9 76 02 00 00	 jmp	 $LN16@gzseek64
$LN13@gzseek64:

; 371  : 
; 372  :     /* can only seek from start or relative to current position */
; 373  :     if (whence != SEEK_SET && whence != SEEK_CUR)

  0005d	83 7d 14 00	 cmp	 DWORD PTR _whence$[ebp], 0
  00061	74 11		 je	 SHORT $LN12@gzseek64
  00063	83 7d 14 01	 cmp	 DWORD PTR _whence$[ebp], 1
  00067	74 0b		 je	 SHORT $LN12@gzseek64

; 374  :         return -1;

  00069	83 c8 ff	 or	 eax, -1
  0006c	83 ca ff	 or	 edx, -1
  0006f	e9 5f 02 00 00	 jmp	 $LN16@gzseek64
$LN12@gzseek64:

; 375  : 
; 376  :     /* normalize offset to a SEEK_CUR specification */
; 377  :     if (whence == SEEK_SET)

  00074	83 7d 14 00	 cmp	 DWORD PTR _whence$[ebp], 0
  00078	75 17		 jne	 SHORT $LN11@gzseek64

; 378  :         offset -= state->x.pos;

  0007a	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  0007d	8b 45 0c	 mov	 eax, DWORD PTR _offset$[ebp]
  00080	2b 42 08	 sub	 eax, DWORD PTR [edx+8]
  00083	8b 4d 10	 mov	 ecx, DWORD PTR _offset$[ebp+4]
  00086	1b 4a 0c	 sbb	 ecx, DWORD PTR [edx+12]
  00089	89 45 0c	 mov	 DWORD PTR _offset$[ebp], eax
  0008c	89 4d 10	 mov	 DWORD PTR _offset$[ebp+4], ecx
  0008f	eb 1e		 jmp	 SHORT $LN10@gzseek64
$LN11@gzseek64:

; 379  :     else if (state->seek)

  00091	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  00094	83 7a 58 00	 cmp	 DWORD PTR [edx+88], 0
  00098	74 15		 je	 SHORT $LN10@gzseek64

; 380  :         offset += state->skip;

  0009a	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  0009d	8b 4d 0c	 mov	 ecx, DWORD PTR _offset$[ebp]
  000a0	03 48 50	 add	 ecx, DWORD PTR [eax+80]
  000a3	8b 55 10	 mov	 edx, DWORD PTR _offset$[ebp+4]
  000a6	13 50 54	 adc	 edx, DWORD PTR [eax+84]
  000a9	89 4d 0c	 mov	 DWORD PTR _offset$[ebp], ecx
  000ac	89 55 10	 mov	 DWORD PTR _offset$[ebp+4], edx
$LN10@gzseek64:

; 381  :     state->seek = 0;

  000af	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  000b2	c7 40 58 00 00
	00 00		 mov	 DWORD PTR [eax+88], 0

; 382  : 
; 383  :     /* if within raw area while reading, just go there */
; 384  :     if (state->mode == GZ_READ && state->how == COPY &&
; 385  :             state->x.pos + offset >= 0) {

  000b9	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  000bc	81 79 10 4f 1c
	00 00		 cmp	 DWORD PTR [ecx+16], 7247 ; 00001c4fH
  000c3	0f 85 db 00 00
	00		 jne	 $LN8@gzseek64
  000c9	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  000cc	83 7a 30 01	 cmp	 DWORD PTR [edx+48], 1
  000d0	0f 85 ce 00 00
	00		 jne	 $LN8@gzseek64
  000d6	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  000d9	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000dc	03 4d 0c	 add	 ecx, DWORD PTR _offset$[ebp]
  000df	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  000e2	13 55 10	 adc	 edx, DWORD PTR _offset$[ebp+4]
  000e5	89 4d e4	 mov	 DWORD PTR tv211[ebp], ecx
  000e8	89 55 e8	 mov	 DWORD PTR tv211[ebp+4], edx
  000eb	0f 88 b3 00 00
	00		 js	 $LN8@gzseek64
  000f1	7f 0a		 jg	 SHORT $LN20@gzseek64
  000f3	83 7d e4 00	 cmp	 DWORD PTR tv211[ebp], 0
  000f7	0f 82 a7 00 00
	00		 jb	 $LN8@gzseek64
$LN20@gzseek64:

; 386  :         ret = LSEEK(state->fd, offset - state->x.have, SEEK_CUR);

  000fd	6a 01		 push	 1
  000ff	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  00102	8b 08		 mov	 ecx, DWORD PTR [eax]
  00104	33 d2		 xor	 edx, edx
  00106	8b 45 0c	 mov	 eax, DWORD PTR _offset$[ebp]
  00109	2b c1		 sub	 eax, ecx
  0010b	8b 4d 10	 mov	 ecx, DWORD PTR _offset$[ebp+4]
  0010e	1b ca		 sbb	 ecx, edx
  00110	51		 push	 ecx
  00111	50		 push	 eax
  00112	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  00115	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00118	50		 push	 eax
  00119	e8 00 00 00 00	 call	 __lseeki64
  0011e	83 c4 10	 add	 esp, 16			; 00000010H
  00121	89 45 f0	 mov	 DWORD PTR _ret$[ebp], eax
  00124	89 55 f4	 mov	 DWORD PTR _ret$[ebp+4], edx

; 387  :         if (ret == -1)

  00127	8b 4d f0	 mov	 ecx, DWORD PTR _ret$[ebp]
  0012a	23 4d f4	 and	 ecx, DWORD PTR _ret$[ebp+4]
  0012d	83 f9 ff	 cmp	 ecx, -1
  00130	75 0b		 jne	 SHORT $LN7@gzseek64

; 388  :             return -1;

  00132	83 c8 ff	 or	 eax, -1
  00135	83 ca ff	 or	 edx, -1
  00138	e9 96 01 00 00	 jmp	 $LN16@gzseek64
$LN7@gzseek64:

; 389  :         state->x.have = 0;

  0013d	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  00140	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 390  :         state->eof = 0;

  00146	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  00149	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [eax+64], 0

; 391  :         state->past = 0;

  00150	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  00153	c7 41 44 00 00
	00 00		 mov	 DWORD PTR [ecx+68], 0

; 392  :         state->seek = 0;

  0015a	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  0015d	c7 42 58 00 00
	00 00		 mov	 DWORD PTR [edx+88], 0

; 393  :         gz_error(state, Z_OK, NULL);

  00164	6a 00		 push	 0
  00166	6a 00		 push	 0
  00168	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  0016b	50		 push	 eax
  0016c	e8 00 00 00 00	 call	 _gz_error
  00171	83 c4 0c	 add	 esp, 12			; 0000000cH

; 394  :         state->strm.avail_in = 0;

  00174	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  00177	c7 41 68 00 00
	00 00		 mov	 DWORD PTR [ecx+104], 0

; 395  :         state->x.pos += offset;

  0017e	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  00181	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00184	03 45 0c	 add	 eax, DWORD PTR _offset$[ebp]
  00187	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  0018a	13 4d 10	 adc	 ecx, DWORD PTR _offset$[ebp+4]
  0018d	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  00190	89 42 08	 mov	 DWORD PTR [edx+8], eax
  00193	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 396  :         return state->x.pos;

  00196	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  00199	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0019c	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0019f	e9 2f 01 00 00	 jmp	 $LN16@gzseek64
$LN8@gzseek64:

; 397  :     }
; 398  : 
; 399  :     /* calculate skip amount, rewinding if needed for back seek when reading */
; 400  :     if (offset < 0) {

  001a4	83 7d 10 00	 cmp	 DWORD PTR _offset$[ebp+4], 0
  001a8	7f 66		 jg	 SHORT $LN6@gzseek64
  001aa	7c 06		 jl	 SHORT $LN21@gzseek64
  001ac	83 7d 0c 00	 cmp	 DWORD PTR _offset$[ebp], 0
  001b0	73 5e		 jae	 SHORT $LN6@gzseek64
$LN21@gzseek64:

; 401  :         if (state->mode != GZ_READ)         /* writing -- can't go backwards */

  001b2	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  001b5	81 7a 10 4f 1c
	00 00		 cmp	 DWORD PTR [edx+16], 7247 ; 00001c4fH
  001bc	74 0b		 je	 SHORT $LN5@gzseek64

; 402  :             return -1;

  001be	83 c8 ff	 or	 eax, -1
  001c1	83 ca ff	 or	 edx, -1
  001c4	e9 0a 01 00 00	 jmp	 $LN16@gzseek64
$LN5@gzseek64:

; 403  :         offset += state->x.pos;

  001c9	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  001cc	8b 4d 0c	 mov	 ecx, DWORD PTR _offset$[ebp]
  001cf	03 48 08	 add	 ecx, DWORD PTR [eax+8]
  001d2	8b 55 10	 mov	 edx, DWORD PTR _offset$[ebp+4]
  001d5	13 50 0c	 adc	 edx, DWORD PTR [eax+12]
  001d8	89 4d 0c	 mov	 DWORD PTR _offset$[ebp], ecx
  001db	89 55 10	 mov	 DWORD PTR _offset$[ebp+4], edx

; 404  :         if (offset < 0)                     /* before start of file! */

  001de	83 7d 10 00	 cmp	 DWORD PTR _offset$[ebp+4], 0
  001e2	7f 13		 jg	 SHORT $LN4@gzseek64
  001e4	7c 06		 jl	 SHORT $LN22@gzseek64
  001e6	83 7d 0c 00	 cmp	 DWORD PTR _offset$[ebp], 0
  001ea	73 0b		 jae	 SHORT $LN4@gzseek64
$LN22@gzseek64:

; 405  :             return -1;

  001ec	83 c8 ff	 or	 eax, -1
  001ef	83 ca ff	 or	 edx, -1
  001f2	e9 dc 00 00 00	 jmp	 $LN16@gzseek64
$LN4@gzseek64:

; 406  :         if (gzrewind(file) == -1)           /* rewind, then skip to offset */

  001f7	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  001fa	50		 push	 eax
  001fb	e8 00 00 00 00	 call	 _gzrewind@4
  00200	83 f8 ff	 cmp	 eax, -1
  00203	75 0b		 jne	 SHORT $LN6@gzseek64

; 407  :             return -1;

  00205	83 c8 ff	 or	 eax, -1
  00208	83 ca ff	 or	 edx, -1
  0020b	e9 c3 00 00 00	 jmp	 $LN16@gzseek64
$LN6@gzseek64:

; 408  :     }
; 409  : 
; 410  :     /* if reading, skip what's in output buffer (one less gzgetc() check) */
; 411  :     if (state->mode == GZ_READ) {

  00210	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  00213	81 79 10 4f 1c
	00 00		 cmp	 DWORD PTR [ecx+16], 7247 ; 00001c4fH
  0021a	0f 85 83 00 00
	00		 jne	 $LN2@gzseek64

; 412  :         n = GT_OFF(state->x.have) || (z_off64_t)state->x.have > offset ?
; 413  :             (unsigned)offset : state->x.have;

  00220	33 d2		 xor	 edx, edx
  00222	75 29		 jne	 SHORT $LN18@gzseek64
  00224	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  00227	8b 08		 mov	 ecx, DWORD PTR [eax]
  00229	33 d2		 xor	 edx, edx
  0022b	89 4d dc	 mov	 DWORD PTR tv282[ebp], ecx
  0022e	89 55 e0	 mov	 DWORD PTR tv282[ebp+4], edx
  00231	8b 45 e0	 mov	 eax, DWORD PTR tv282[ebp+4]
  00234	3b 45 10	 cmp	 eax, DWORD PTR _offset$[ebp+4]
  00237	7f 14		 jg	 SHORT $LN18@gzseek64
  00239	7c 08		 jl	 SHORT $LN23@gzseek64
  0023b	8b 4d dc	 mov	 ecx, DWORD PTR tv282[ebp]
  0023e	3b 4d 0c	 cmp	 ecx, DWORD PTR _offset$[ebp]
  00241	77 0a		 ja	 SHORT $LN18@gzseek64
$LN23@gzseek64:
  00243	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  00246	8b 02		 mov	 eax, DWORD PTR [edx]
  00248	89 45 d8	 mov	 DWORD PTR tv156[ebp], eax
  0024b	eb 06		 jmp	 SHORT $LN19@gzseek64
$LN18@gzseek64:
  0024d	8b 4d 0c	 mov	 ecx, DWORD PTR _offset$[ebp]
  00250	89 4d d8	 mov	 DWORD PTR tv156[ebp], ecx
$LN19@gzseek64:
  00253	8b 55 d8	 mov	 edx, DWORD PTR tv156[ebp]
  00256	89 55 fc	 mov	 DWORD PTR _n$[ebp], edx

; 414  :         state->x.have -= n;

  00259	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  0025c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0025e	2b 4d fc	 sub	 ecx, DWORD PTR _n$[ebp]
  00261	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  00264	89 0a		 mov	 DWORD PTR [edx], ecx

; 415  :         state->x.next += n;

  00266	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  00269	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0026c	03 4d fc	 add	 ecx, DWORD PTR _n$[ebp]
  0026f	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  00272	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 416  :         state->x.pos += n;

  00275	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  00278	33 c9		 xor	 ecx, ecx
  0027a	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  0027d	03 42 08	 add	 eax, DWORD PTR [edx+8]
  00280	8b 52 0c	 mov	 edx, DWORD PTR [edx+12]
  00283	13 d1		 adc	 edx, ecx
  00285	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  00288	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0028b	89 51 0c	 mov	 DWORD PTR [ecx+12], edx

; 417  :         offset -= n;

  0028e	8b 55 fc	 mov	 edx, DWORD PTR _n$[ebp]
  00291	33 c0		 xor	 eax, eax
  00293	8b 4d 0c	 mov	 ecx, DWORD PTR _offset$[ebp]
  00296	2b ca		 sub	 ecx, edx
  00298	8b 55 10	 mov	 edx, DWORD PTR _offset$[ebp+4]
  0029b	1b d0		 sbb	 edx, eax
  0029d	89 4d 0c	 mov	 DWORD PTR _offset$[ebp], ecx
  002a0	89 55 10	 mov	 DWORD PTR _offset$[ebp+4], edx
$LN2@gzseek64:

; 418  :     }
; 419  : 
; 420  :     /* request skip (if not zero) */
; 421  :     if (offset) {

  002a3	8b 45 0c	 mov	 eax, DWORD PTR _offset$[ebp]
  002a6	0b 45 10	 or	 eax, DWORD PTR _offset$[ebp+4]
  002a9	74 19		 je	 SHORT $LN1@gzseek64

; 422  :         state->seek = 1;

  002ab	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  002ae	c7 41 58 01 00
	00 00		 mov	 DWORD PTR [ecx+88], 1

; 423  :         state->skip = offset;

  002b5	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  002b8	8b 45 0c	 mov	 eax, DWORD PTR _offset$[ebp]
  002bb	89 42 50	 mov	 DWORD PTR [edx+80], eax
  002be	8b 4d 10	 mov	 ecx, DWORD PTR _offset$[ebp+4]
  002c1	89 4a 54	 mov	 DWORD PTR [edx+84], ecx
$LN1@gzseek64:

; 424  :     }
; 425  :     return state->x.pos + offset;

  002c4	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  002c7	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  002ca	03 45 0c	 add	 eax, DWORD PTR _offset$[ebp]
  002cd	8b 52 0c	 mov	 edx, DWORD PTR [edx+12]
  002d0	13 55 10	 adc	 edx, DWORD PTR _offset$[ebp+4]
$LN16@gzseek64:

; 426  : }

  002d3	8b e5		 mov	 esp, ebp
  002d5	5d		 pop	 ebp
  002d6	c2 10 00	 ret	 16			; 00000010H
_gzseek64@16 ENDP
_TEXT	ENDS
PUBLIC	_gzopen_w@8
; Function compile flags: /Odtp
;	COMDAT _gzopen_w@8
_TEXT	SEGMENT
_path$ = 8						; size = 4
_mode$ = 12						; size = 4
_gzopen_w@8 PROC					; COMDAT

; 298  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 299  :     return gz_open(path, -2, mode);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _mode$[ebp]
  00006	50		 push	 eax
  00007	6a fe		 push	 -2			; fffffffeH
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _path$[ebp]
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 _gz_open
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH

; 300  : }

  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
_gzopen_w@8 ENDP
_TEXT	ENDS
PUBLIC	_gzdopen@8
; Function compile flags: /Odtp
;	COMDAT _gzdopen@8
_TEXT	SEGMENT
_path$ = -8						; size = 4
_gz$ = -4						; size = 4
_fd$ = 8						; size = 4
_mode$ = 12						; size = 4
_gzdopen@8 PROC						; COMDAT

; 281  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 282  :     char *path;         /* identifier for error messages */
; 283  :     gzFile gz;
; 284  : 
; 285  :     if (fd == -1 || (path = malloc(7 + 3 * sizeof(int))) == NULL)

  00006	83 7d 08 ff	 cmp	 DWORD PTR _fd$[ebp], -1
  0000a	74 13		 je	 SHORT $LN1@gzdopen
  0000c	6a 13		 push	 19			; 00000013H
  0000e	e8 00 00 00 00	 call	 _malloc
  00013	83 c4 04	 add	 esp, 4
  00016	89 45 f8	 mov	 DWORD PTR _path$[ebp], eax
  00019	83 7d f8 00	 cmp	 DWORD PTR _path$[ebp], 0
  0001d	75 04		 jne	 SHORT $LN2@gzdopen
$LN1@gzdopen:

; 286  :         return NULL;

  0001f	33 c0		 xor	 eax, eax
  00021	eb 3b		 jmp	 SHORT $LN3@gzdopen
$LN2@gzdopen:

; 287  :     sprintf(path, "<fd:%d>", fd);   /* for debugging */

  00023	8b 45 08	 mov	 eax, DWORD PTR _fd$[ebp]
  00026	50		 push	 eax
  00027	68 00 00 00 00	 push	 OFFSET ??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO?$AA@
  0002c	8b 4d f8	 mov	 ecx, DWORD PTR _path$[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 _sprintf
  00035	83 c4 0c	 add	 esp, 12			; 0000000cH

; 288  :     gz = gz_open(path, fd, mode);

  00038	8b 55 0c	 mov	 edx, DWORD PTR _mode$[ebp]
  0003b	52		 push	 edx
  0003c	8b 45 08	 mov	 eax, DWORD PTR _fd$[ebp]
  0003f	50		 push	 eax
  00040	8b 4d f8	 mov	 ecx, DWORD PTR _path$[ebp]
  00043	51		 push	 ecx
  00044	e8 00 00 00 00	 call	 _gz_open
  00049	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004c	89 45 fc	 mov	 DWORD PTR _gz$[ebp], eax

; 289  :     free(path);

  0004f	8b 55 f8	 mov	 edx, DWORD PTR _path$[ebp]
  00052	52		 push	 edx
  00053	e8 00 00 00 00	 call	 _free
  00058	83 c4 04	 add	 esp, 4

; 290  :     return gz;

  0005b	8b 45 fc	 mov	 eax, DWORD PTR _gz$[ebp]
$LN3@gzdopen:

; 291  : }

  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c2 08 00	 ret	 8
_gzdopen@8 ENDP
_TEXT	ENDS
PUBLIC	_gzopen@8
; Function compile flags: /Odtp
;	COMDAT _gzopen@8
_TEXT	SEGMENT
_path$ = 8						; size = 4
_mode$ = 12						; size = 4
_gzopen@8 PROC						; COMDAT

; 265  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 266  :     return gz_open(path, -1, mode);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _mode$[ebp]
  00006	50		 push	 eax
  00007	6a ff		 push	 -1
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _path$[ebp]
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 _gz_open
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH

; 267  : }

  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
_gzopen@8 ENDP
PUBLIC	_gzseek@12
; Function compile flags: /Odtp
;	COMDAT _gzseek@12
_TEXT	SEGMENT
tv73 = -20						; size = 4
tv95 = -16						; size = 8
_ret$ = -8						; size = 8
_file$ = 8						; size = 4
_offset$ = 12						; size = 4
_whence$ = 16						; size = 4
_gzseek@12 PROC						; COMDAT

; 433  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 434  :     z_off64_t ret;
; 435  : 
; 436  :     ret = gzseek64(file, (z_off64_t)offset, whence);

  00006	8b 45 10	 mov	 eax, DWORD PTR _whence$[ebp]
  00009	50		 push	 eax
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _offset$[ebp]
  0000d	99		 cdq
  0000e	52		 push	 edx
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _file$[ebp]
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 _gzseek64@16
  00019	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax
  0001c	89 55 fc	 mov	 DWORD PTR _ret$[ebp+4], edx

; 437  :     return ret == (z_off_t)ret ? (z_off_t)ret : -1;

  0001f	8b 45 f8	 mov	 eax, DWORD PTR _ret$[ebp]
  00022	99		 cdq
  00023	89 45 f0	 mov	 DWORD PTR tv95[ebp], eax
  00026	89 55 f4	 mov	 DWORD PTR tv95[ebp+4], edx
  00029	8b 55 f8	 mov	 edx, DWORD PTR _ret$[ebp]
  0002c	3b 55 f0	 cmp	 edx, DWORD PTR tv95[ebp]
  0002f	75 10		 jne	 SHORT $LN3@gzseek
  00031	8b 45 fc	 mov	 eax, DWORD PTR _ret$[ebp+4]
  00034	3b 45 f4	 cmp	 eax, DWORD PTR tv95[ebp+4]
  00037	75 08		 jne	 SHORT $LN3@gzseek
  00039	8b 4d f8	 mov	 ecx, DWORD PTR _ret$[ebp]
  0003c	89 4d ec	 mov	 DWORD PTR tv73[ebp], ecx
  0003f	eb 07		 jmp	 SHORT $LN4@gzseek
$LN3@gzseek:
  00041	c7 45 ec ff ff
	ff ff		 mov	 DWORD PTR tv73[ebp], -1
$LN4@gzseek:
  00048	8b 45 ec	 mov	 eax, DWORD PTR tv73[ebp]

; 438  : }

  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c2 0c 00	 ret	 12			; 0000000cH
_gzseek@12 ENDP
END
